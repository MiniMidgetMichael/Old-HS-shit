alphabet_dict.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
alphabet_dict.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
alphabet_dict.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
alphabet_dict.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
alphabet_dict.py:from collections import OrderedDict
alphabet_dict.py:alphabet = OrderedDict([
alphabet_dict.py:    ("a" , 1),
alphabet_dict.py:    ("b" , 2),
alphabet_dict.py:    ("c" , 3),
alphabet_dict.py:    ("d" , 4),
alphabet_dict.py:    ("e" , 5),
alphabet_dict.py:    ("f" , 6),
alphabet_dict.py:    ("g" , 7),
alphabet_dict.py:    ("h" , 8),
alphabet_dict.py:    ("i" , 9),
alphabet_dict.py:    ("j" , 10),
alphabet_dict.py:    ("k" , 11),
alphabet_dict.py:    ("l" , 12),
alphabet_dict.py:    ("m" , 13),
alphabet_dict.py:    ("n" , 14),
alphabet_dict.py:    ("o" , 15),
alphabet_dict.py:    ("p" , 16),
alphabet_dict.py:    ("q" , 17),
alphabet_dict.py:    ("r" , 18),
alphabet_dict.py:    ("s" , 19),
alphabet_dict.py:    ("t" , 20),
alphabet_dict.py:    ("u" , 21),
alphabet_dict.py:    ("v" , 22),
alphabet_dict.py:    ("w" , 23),
alphabet_dict.py:    ("x" , 24),
alphabet_dict.py:    ("y" , 25),
alphabet_dict.py:    ("z" , 26),
alphabet_dict.py:    (" " , 27),
alphabet_dict.py:    ("_" , 28),
alphabet_dict.py:    ("A" , 1),
alphabet_dict.py:    ("B" , 2),
alphabet_dict.py:    ("C" , 3),
alphabet_dict.py:    ("D" , 4),
alphabet_dict.py:    ("E" , 5),
alphabet_dict.py:    ("F" , 6),
alphabet_dict.py:    ("G" , 7),
alphabet_dict.py:    ("H" , 8),
alphabet_dict.py:    ("I" , 9),
alphabet_dict.py:    ("J" , 10),
alphabet_dict.py:    ("K" , 11),
alphabet_dict.py:    ("L" , 12),
alphabet_dict.py:    ("M" , 13),
alphabet_dict.py:    ("N" , 14),
alphabet_dict.py:    ("O" , 15),
alphabet_dict.py:    ("P" , 16),
alphabet_dict.py:    ("Q" , 17),
alphabet_dict.py:    ("R" , 18),
alphabet_dict.py:    ("S" , 19),
alphabet_dict.py:    ("T" , 20),
alphabet_dict.py:    ("U" , 21),
alphabet_dict.py:    ("V" , 22),
alphabet_dict.py:    ("W" , 23),
alphabet_dict.py:    ("X" , 24),
alphabet_dict.py:    ("Y" , 25),
alphabet_dict.py:    ("Z" , 26)
alphabet_dict.py:])
alphabet_dict.py:alphabet_items = list(alphabet.items())
alphabet_dict.py:alphabet_keys = list(alphabet.keys())
alphabet_dict.py:alphabet_values = list(alphabet.values())
bin_with_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
bin_with_input.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
bin_with_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
bin_with_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
bin_with_input.py:from alphabet_dict import *
bin_with_input.py:from number_funct import *
bin_with_input.py:from macpath import *
bin_with_input.py:from pathlib import *
bin_with_input.py:text = input("Please type what you want to be ciphered:")
bin_with_input.py:#print (alphabet)
bin_with_input.py:#print (alphabet_items, alphabet_values)
bin_with_input.py:text_list = []
bin_with_input.py:for i in text:
bin_with_input.py:    if i != " ":
bin_with_input.py:        text_list.append(i)
bin_with_input.py:print ("#text_list", text_list)
bin_with_input.py:old_text = list(text_list)
bin_with_input.py:print ("#old_text", old_text, "\n")
bin_with_input.py:"""OLD_TEXT IS LAST ORDERED LIST"""
bin_with_input.py:only_text = []
bin_with_input.py:leftovers = []
bin_with_input.py:for i in text_list:
bin_with_input.py:    if is_number(i) == False:
bin_with_input.py:        only_text += [i]
bin_with_input.py:    else:
bin_with_input.py:        leftovers += [i]
bin_with_input.py:new_list = []
bin_with_input.py:ordered_text = {}
bin_with_input.py:for index, i in enumerate(leftovers):
bin_with_input.py:    ordered_text[index] = i
bin_with_input.py:"""CREATE DICTIONARY WITH KEYS = INDEX of VALUES & VALUES = TEXT"""
bin_with_input.py:print ("#ordered_text", ordered_text, "\n")
bin_with_input.py:print ("#only_text", only_text, "\n")
bin_with_input.py:print ("#leftovers", leftovers, "\n")
bin_with_input.py:test_tpl = alphabet
bin_with_input.py:mapping = dict(test_tpl)
bin_with_input.py:""" HERE IS WHERE LIST GETS MIXED UP"""
bin_with_input.py:test_tpl = [(x,mapping[x]) for x in only_text]
bin_with_input.py:for a, b in test_tpl:
bin_with_input.py:    new_list.append(b)
bin_with_input.py:for x in ordered_text:
bin_with_input.py:    new_list.insert(x, ordered_text[x])
bin_with_input.py:print ("#new_list", new_list)
bin_with_input.py:print ("#list_to_bin", list_to_bin(new_list), "\n")
bin_with_input.py:print(mix_up(new_list))
Car_Race.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Car_Race.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Car_Race.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Car_Race.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Car_Race.py:import time, sys, random
Car_Race.py:import my_turtle as turtle
Car_Race.py:
Car_Race.py:screen = turtle.Screen()
Car_Race.py:redCar = turtle.Shape("image", data="P:/Python/Resources/Race_Car_Red.gif")
Car_Race.py:whiteCar = turtle.Shape("image", data="P:/Python/Resources/Race_Car_White.gif")
Car_Race.py:screen.register_shape("redCar", "P:/Python/Resources/Race_Car_Red.gif")
Car_Race.py:screen.register_shape("whiteCar", "P:/Python/Resources/Race_Car_White.gif")
Car_Race.py:
Car_Race.py:print (turtle.getshapes())
Car_Race.py:
Car_Race.py:red_car = turtle.Turtle()
Car_Race.py:white_car = turtle.Turtle()
Car_Race.py:
Car_Race.py:red_car.shape("red_car")
Car_Race.py:white_car.shape("white_car")
DNS_Test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
DNS_Test.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
DNS_Test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
DNS_Test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
DNS_Test.py:#!/usr/bin/env python
DNS_Test.py:# -*- coding: utf-8 -*-
DNS_Test.py:
DNS_Test.py:import dns.query
DNS_Test.py:import dns.resolver
DNS_Test.py:from dns.exception import DNSException
DNS_Test.py:
DNS_Test.py:def query_authoritative_ns (domain, log=lambda msg: None):
DNS_Test.py:
DNS_Test.py:    default = dns.resolver.get_default_resolver()
DNS_Test.py:    ns = default.nameservers[0]
DNS_Test.py:
DNS_Test.py:    n = domain.split('.')
DNS_Test.py:
DNS_Test.py:    for i in xrange(len(n), 0, -1):
DNS_Test.py:        sub = '.'.join(n[i-1:])
DNS_Test.py:
DNS_Test.py:        log('Looking up %s on %s' % (sub, ns))
DNS_Test.py:        query = dns.message.make_query(sub, dns.rdatatype.NS)
DNS_Test.py:        response = dns.query.udp(query, ns)
DNS_Test.py:
DNS_Test.py:        rcode = response.rcode()
DNS_Test.py:        if rcode != dns.rcode.NOERROR:
DNS_Test.py:            if rcode == dns.rcode.NXDOMAIN:
DNS_Test.py:                raise Exception('%s does not exist.' % (sub))
DNS_Test.py:            else:
DNS_Test.py:                raise Exception('Error %s' % (dns.rcode.to_text(rcode)))
DNS_Test.py:
DNS_Test.py:        if len(response.authority) > 0:
DNS_Test.py:            rrsets = response.authority
DNS_Test.py:        elif len(response.additional) > 0:
DNS_Test.py:            rrsets = [response.additional]
DNS_Test.py:        else:
DNS_Test.py:            rrsets = response.answer
DNS_Test.py:
DNS_Test.py:        # Handle all RRsets, not just the first one
DNS_Test.py:        for rrset in rrsets:
DNS_Test.py:            for rr in rrset:
DNS_Test.py:                if rr.rdtype == dns.rdatatype.SOA:
DNS_Test.py:                    log('Same server is authoritative for %s' % (sub))
DNS_Test.py:                elif rr.rdtype == dns.rdatatype.A:
DNS_Test.py:                    ns = rr.items[0].address
DNS_Test.py:                    log('Glue record for %s: %s' % (rr.name, ns))
DNS_Test.py:                elif rr.rdtype == dns.rdatatype.NS:
DNS_Test.py:                    authority = rr.target
DNS_Test.py:                    ns = default.query(authority).rrset[0].to_text()
DNS_Test.py:                    log('%s [%s] is authoritative for %s; ttl %i' % 
DNS_Test.py:                        (authority, ns, sub, rrset.ttl))
DNS_Test.py:                    result = rrset
DNS_Test.py:                else:
DNS_Test.py:                    # IPv6 glue records etc
DNS_Test.py:                    #log('Ignoring %s' % (rr))
DNS_Test.py:                    pass
DNS_Test.py:
DNS_Test.py:    return result
DNS_Test.py:
DNS_Test.py:import sys
DNS_Test.py:
DNS_Test.py:def log (msg):
DNS_Test.py:    sys.stderr.write(msg + u'\n')
DNS_Test.py:
DNS_Test.py:for s in sys.argv[1:]:
DNS_Test.py:    print (query_authoritative_ns (s, log))
file_methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_methods.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_methods.py:from fnmatch import *
file_methods.py:from turtledemo import *
file_methods.py:def strip_space(op_file):
file_methods.py:    with open(op_file, "r") as file:
file_methods.py:        ##print (file.read())
file_methods.py:        file_text = str(file.read())
file_methods.py:        ##print (file_text)
file_methods.py:        file_filter = filter(lambda x: x != " ", file_text)
file_methods.py:        file_filtered = [i for i in file_filter]
file_methods.py:        ##print (file_filtered)
file_methods.py:        file_nospace = ""
file_methods.py:        for i in file_filtered:
file_methods.py:            file_nospace += i
file_methods.py:        ##print(file_nospace)
file_methods.py:        return file_nospace
file_methods.py:
file_methods.py:
file_methods.py:##print (strip_space("P:/Python/alphabet_dict.py"))
file_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_test.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
file_test.py:from file_test import *
file_test.py:print(strip_space("P:/Python/alphabet_dict.py"))
Hex_Bin_Dec_Converter.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Hex_Bin_Dec_Converter.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Hex_Bin_Dec_Converter.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Hex_Bin_Dec_Converter.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Hex_Bin_Dec_Converter.py:﻿from number_funct import *
Hex_Bin_Dec_Converter.py:import math
Hex_Bin_Dec_Converter.py:import methods
Hex_Bin_Dec_Converter.py:
Hex_Bin_Dec_Converter.py:types = ("b", "d", "h")
Hex_Bin_Dec_Converter.py:c_hex = False
Hex_Bin_Dec_Converter.py:c_dec = False
Hex_Bin_Dec_Converter.py:c_bin = True
Hex_Bin_Dec_Converter.py:
Hex_Bin_Dec_Converter.py:"""
Hex_Bin_Dec_Converter.py:"What data type do you wish to convert? \n [d]ecimal [b]inary [h]exadecimal \n"
Hex_Bin_Dec_Converter.py:"""
Hex_Bin_Dec_Converter.py:
Hex_Bin_Dec_Converter.py:ans = methods.good_input("What data type do you wish to convert? \n [d]ecimal [b]inary [h]exadecimal \n", "b", "d", c="h")
Hex_Bin_Dec_Converter.py:
Hex_Bin_Dec_Converter.py:if ans[1] == "b":
Hex_Bin_Dec_Converter.py:    c_bin = True
Hex_Bin_Dec_Converter.py:elif ans[1] == "d":
Hex_Bin_Dec_Converter.py:    c_dec = True
Hex_Bin_Dec_Converter.py:elif ans[1] == "h":
Hex_Bin_Dec_Converter.py:    c_hex = True
Hex_Bin_Dec_Converter.py:
Hex_Bin_Dec_Converter.py:def get_value(query, v_type, fun):
Hex_Bin_Dec_Converter.py:    value = input(query)
Hex_Bin_Dec_Converter.py:    if (fun(value) == True):
Hex_Bin_Dec_Converter.py:        #isGoodValue = True
Hex_Bin_Dec_Converter.py:        print (fun(value))
Hex_Bin_Dec_Converter.py:        return value
Hex_Bin_Dec_Converter.py:        ##pass
Hex_Bin_Dec_Converter.py:    else:
Hex_Bin_Dec_Converter.py:        print ("%s is not a " % value + v_type)
Hex_Bin_Dec_Converter.py:        get_value(query, v_type, fun)
Hex_Bin_Dec_Converter.py:if (c_dec):
Hex_Bin_Dec_Converter.py:    value = get_value("Please give a decimal value: \n", "decimal", is_number)
Hex_Bin_Dec_Converter.py:    ##value = int(value)
Hex_Bin_Dec_Converter.py:    print ("#value: \n", value)
Hex_Bin_Dec_Converter.py:    (dec_to_hex(value))
Hex_Bin_Dec_Converter.py:    
hex_values.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex_values.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex_values.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex_values.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex_values.py:from collections import OrderedDict
hex_values.py:hex_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f"]
hex_values.py:hex_dict = OrderedDict ({
hex_values.py:    (0 , 0),
hex_values.py:    (1 , 1),
hex_values.py:    (2 , 2),
hex_values.py:    (3 , 3),
hex_values.py:    (4 , 4),
hex_values.py:    (5 , 5),
hex_values.py:    (6 , 6),
hex_values.py:    (7 , 7),
hex_values.py:    (8 , 8),
hex_values.py:    (9 , 9),
hex_values.py:    ("a" , 10),
hex_values.py:    ("b" , 11),
hex_values.py:    ("c" , 12),
hex_values.py:    ("d" , 13),
hex_values.py:    ("e" , 14),
hex_values.py:    ("f" , 15)
hex_values.py:})
hex_values.py:hex_keys = list(hex_dict.keys())
hex_values.py:#print (hex_keys)
hex_values.py:hex_values = list(hex_dict.values())
hex-bin_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex-bin_input.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex-bin_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex-bin_input.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
hex-bin_input.py:from hex_values import *
hex-bin_input.py:from number_funct import *
hex-bin_input.py:from methods import *
hex-bin_input.py:from signature import *
hex-bin_input.py:
hex-bin_input.py:
hex-bin_input.py:hex_or_dec = input("Dec to Hex [A] \n or \n" + "Hex to Dec [B] \n")
hex-bin_input.py:
hex-bin_input.py:dec_to_hex = False
hex-bin_input.py:hex_to_dec = False
hex-bin_input.py:if (hex_or_dec.casefold() == "A"):
hex-bin_input.py:    dec_to_hex = True
hex-bin_input.py:elif (hex_or_dec.casefold() == "B"):
hex-bin_input.py:    hex_to_dec = True
hex-bin_input.py:
HSCTF_Num-Alpha.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
HSCTF_Num-Alpha.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
HSCTF_Num-Alpha.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
HSCTF_Num-Alpha.py:from alphabet_dict import alphabet, alphabet_items, alphabet_values, alphabet_keys
HSCTF_Num-Alpha.py:from collections import OrderedDict
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:##print (alphabet_keys, alphabet_values)
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:nums_1 = (23, 5, 12, 12, 27, 20, 8, 5, 27, 6, 12, 1, 7, 27, 9, 19, 27, 8, 9, 4, 4, 5, 14, 27, 8, 5, 18, 5, 27, 2, 21, 20, 27, 6, 9, 18, 19, 20, 27, 23, 5, 27, 8, 1, 22, 5, 27, 19, 15, 13, 5, 27, 20, 5, 24, 20, 27, 20, 15, 27, 3, 15, 14, 6, 21, 19, 5, 27, 25, 15, 21, 27, 14, 15, 23, 27, 20, 8, 5, 27, 6, 12, 1, 7, 27, 9, 19, 27, 9, 14, 27, 6, 1, 3, 20, 27, 19, 5, 3, 18, 5, 20, 19, 28, 1, 18, 5, 28, 8, 9, 4, 4, 5, 14, 28, 9, 14, 28, 20, 8, 9, 19, 28, 12, 9, 19, 20, 27, 4, 15, 14, 20, 27, 9, 14, 3, 12, 21, 4, 5, 27, 20, 8, 5, 27, 16, 1, 18, 20, 19, 27, 20, 8, 1, 20, 27, 1, 18, 5, 27, 19, 5, 16, 5, 18, 1, 20, 5, 4, 27, 23, 9, 20, 8, 27, 19, 16, 1, 3, 5, 19)
HSCTF_Num-Alpha.py:alphas = []
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:for i in nums_1:
HSCTF_Num-Alpha.py:    alphas += alphabet_keys[alphabet_values.index(i)]
HSCTF_Num-Alpha.py:    ##print (i)
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:##print (alphas)
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:print (''.join(alphas))
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:nums_2 = (22,12,200,12,1000,212,12,1000,210,201,12,1000,202,12,200,112,1,200,221,1000,202,120,1000,21,12,202,1000,202,22,12,1000,20,110,1,21,1000,202,22,200,12,12,1001,11,100,21,100,202,201,1001,100,201,112,202,1001,211,12,200,221,1001,201,12,10,210,200,12)
HSCTF_Num-Alpha.py:
HSCTF_Num-Alpha.py:for i in nums_2:
HSCTF_Num-Alpha.py:    pass
is_number.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:#test
is_number.py:echo #! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
is_number.py:def is_number(x):
is_number.py:    try:
is_number.py:        float(x)
is_number.py:        return True
is_number.py:    except ValueError:
is_number.py:        return False
is_number.py:#print (is_number("3"))
is_number.py:#! C:\Users\MichaelLFarwell\AppData\Local\Programs\Python\Python35-32\python.exe
methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
methods.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
methods.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
methods.py:from collections import OrderedDict
methods.py:from number_funct import *
methods.py:from alphabet_dict import *
methods.py:
methods.py:def make_ordered_dict(keys, values):
methods.py:    new_dict = OrderedDict ({})
methods.py:    for index, i in enumerate(keys):
methods.py:        new_dict[i] = values[index]
methods.py:    return new_dict
methods.py:
methods.py:##test_keys = [0, 1, 2, 3]
methods.py:##test_values = ["a", "b", "c", "d"]
methods.py:##print(make_ordered_dict(test_keys, test_values))
methods.py:
methods.py:def filter_non_hex(in_text):
methods.py:    in_text_filtered = list(filter(lambda x: not(x in hex), in_text))
methods.py:    for index, i in enumerate(in_text_filtered):
methods.py:        if i == " ":
methods.py:            in_text_filtered.pop(index)
methods.py:        elif is_number(i):
methods.py:            in_text_filtered.pop(index)
methods.py:    return in_text_filtered
methods.py:
methods.py:def split_up_hex(hex_lst):
methods.py:    location = 1
methods.py:    op_list = []
methods.py:    pairs = ""
methods.py:    if len(hex_lst) % 2 > 0:
methods.py:        print ("Length of hex string is not divisible by two, appending '0'")
methods.py:        hex_lst.append(0)
methods.py:    for index, i in enumerate(hex_lst):
methods.py:        location += 1
methods.py:        if location % 2 == 0:
methods.py:            ##print (hex_lst[index:location])
methods.py:            pairs += str(hex_lst[index])
methods.py:            pairs += str(hex_lst[location-1])
methods.py:            pairs += " "
methods.py:            ##op_list.append(hex_lst[index:location])
methods.py:            ##print (pairs)
methods.py:    #print ("#pairs:", pairs)
methods.py:    return pairs
methods.py:
methods.py:def pairs_list(hex_pairs):
methods.py:    hex_pairs = list(hex_pairs)
methods.py:    hex_nums_list = []
methods.py:    num_count = 0
methods.py:    num_pair = ""
methods.py:    for index, i in enumerate(hex_pairs):
methods.py:        if i != " ":
methods.py:            num_count += 1
methods.py:        if num_count == 2:
methods.py:            ##print (hex_pairs[index-1], hex_pairs[index])
methods.py:            num_count = 0
methods.py:            num_pair = hex_pairs[index-1] + hex_pairs[index]
methods.py:            hex_nums_list.append(num_pair)
methods.py:    #print (hex_nums_list)
methods.py:    return hex_nums_list
methods.py:
methods.py:def pairs_num_value(hex_pairs):
methods.py:    dbl_array = []
methods.py:    for index, i in enumerate(hex_pairs):
methods.py:        ##print (index, i)
methods.py:        dbl_array.append([hex_pairs[index][0], hex_pairs[index][1]])
methods.py:        ##creates 2d array | [[0,1],[2,3]]
methods.py:    num_array = []
methods.py:    for i, k in dbl_array:
methods.py:        if (is_number(i) == False) and (is_number(k) == False):
methods.py:            i = hex_dict[i]
methods.py:            k = hex_dict[k]
methods.py:            num_array.append([int(i), int(k)])
methods.py:        elif (is_number(i) == False):
methods.py:            i = hex_dict[i]
methods.py:            num_array.append([int(i), int(k)])
methods.py:        elif (is_number(k) == False):
methods.py:            k = hex_dict[k]
methods.py:            num_array.append([int(i), int(k)])
methods.py:        else:
methods.py:            num_array.append([int(i), int(k)])
methods.py:    #print (dbl_array)
methods.py:    #print (num_array)
methods.py:    return (num_array)
methods.py:
methods.py:def pairs_value(num_pairs):
methods.py:    values = []
methods.py:    values_str = ""
methods.py:    for i, k in num_pairs:
methods.py:        ##print (i, k)
methods.py:        values.append((i*(16) + k))
methods.py:    print ("#values", values, "\n")
methods.py:    for i in values:
methods.py:        if len(str(i)) < 2:
methods.py:            ##print ("#i", i)
methods.py:            values_str += "0" + str(i) + " "
methods.py:        else:
methods.py:            values_str += str(i) + " "
methods.py:    print ("#values_str", values_str, "\n")
methods.py:    return values_str
methods.py:
methods.py:
methods.py:
methods.py:def good_input(in_query, g=None, b=None, c=None):
methods.py:    outcomes = (g, b, c)
methods.py:    isGood = False
methods.py:    while (isGood == False):
methods.py:        ans = input(in_query).casefold()
methods.py:        if (((ans == g) or (ans == b) or (ans == c))):
methods.py:            isGood = True
methods.py:            return isGood, ans
methods.py:        else:
methods.py:            ##print ("Please answer with " + g + " or " + b + " or " + c + "\n Your answer: %s" % ans)
methods.py:            ans = ""
methods.py:
methods.py:def clearscreen():
methods.py:    print ("\n" * 100)
methods.py:
methods.py:def is_alphanumeric(x):
methods.py:    if x in alphabet.keys():
methods.py:        return True
methods.py:    else:
methods.py:        try:
methods.py:            int(x)
methods.py:            return True
methods.py:        except:
methods.py:            ValueError
my_turtle.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
my_turtle.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
my_turtle.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
my_turtle.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
my_turtle.py:#
my_turtle.py:# turtle.py: a Tkinter based turtle graphics module for Python
my_turtle.py:# Version 1.1b - 4. 5. 2009
my_turtle.py:#
my_turtle.py:# Copyright (C) 2006 - 2010  Gregor Lingl
my_turtle.py:# email: glingl@aon.at
my_turtle.py:#
my_turtle.py:# This software is provided 'as-is', without any express or implied
my_turtle.py:# warranty.  In no event will the authors be held liable for any damages
my_turtle.py:# arising from the use of this software.
my_turtle.py:#
my_turtle.py:# Permission is granted to anyone to use this software for any purpose,
my_turtle.py:# including commercial applications, and to alter it and redistribute it
my_turtle.py:# freely, subject to the following restrictions:
my_turtle.py:#
my_turtle.py:# 1. The origin of this software must not be misrepresented; you must not
my_turtle.py:#    claim that you wrote the original software. If you use this software
my_turtle.py:#    in a product, an acknowledgment in the product documentation would be
my_turtle.py:#    appreciated but is not required.
my_turtle.py:# 2. Altered source versions must be plainly marked as such, and must not be
my_turtle.py:#    misrepresented as being the original software.
my_turtle.py:# 3. This notice may not be removed or altered from any source distribution.
my_turtle.py:
my_turtle.py:
my_turtle.py:"""
my_turtle.py:Turtle graphics is a popular way for introducing programming to
my_turtle.py:kids. It was part of the original Logo programming language developed
my_turtle.py:by Wally Feurzig and Seymour Papert in 1966.
my_turtle.py:
my_turtle.py:Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it
my_turtle.py:the command turtle.forward(15), and it moves (on-screen!) 15 pixels in
my_turtle.py:the direction it is facing, drawing a line as it moves. Give it the
my_turtle.py:command turtle.right(25), and it rotates in-place 25 degrees clockwise.
my_turtle.py:
my_turtle.py:By combining together these and similar commands, intricate shapes and
my_turtle.py:pictures can easily be drawn.
my_turtle.py:
my_turtle.py:----- turtle.py
my_turtle.py:
my_turtle.py:This module is an extended reimplementation of turtle.py from the
my_turtle.py:Python standard distribution up to Python 2.5. (See: http://www.python.org)
my_turtle.py:
my_turtle.py:It tries to keep the merits of turtle.py and to be (nearly) 100%
my_turtle.py:compatible with it. This means in the first place to enable the
my_turtle.py:learning programmer to use all the commands, classes and methods
my_turtle.py:interactively when using the module from within IDLE run with
my_turtle.py:the -n switch.
my_turtle.py:
my_turtle.py:Roughly it has the following features added:
my_turtle.py:
my_turtle.py:- Better animation of the turtle movements, especially of turning the
my_turtle.py:  turtle. So the turtles can more easily be used as a visual feedback
my_turtle.py:  instrument by the (beginning) programmer.
my_turtle.py:
my_turtle.py:- Different turtle shapes, gif-images as turtle shapes, user defined
my_turtle.py:  and user controllable turtle shapes, among them compound
my_turtle.py:  (multicolored) shapes. Turtle shapes can be stretched and tilted, which
my_turtle.py:  makes turtles very versatile geometrical objects.
my_turtle.py:
my_turtle.py:- Fine control over turtle movement and screen updates via delay(),
my_turtle.py:  and enhanced tracer() and speed() methods.
my_turtle.py:
my_turtle.py:- Aliases for the most commonly used commands, like fd for forward etc.,
my_turtle.py:  following the early Logo traditions. This reduces the boring work of
my_turtle.py:  typing long sequences of commands, which often occur in a natural way
my_turtle.py:  when kids try to program fancy pictures on their first encounter with
my_turtle.py:  turtle graphics.
my_turtle.py:
my_turtle.py:- Turtles now have an undo()-method with configurable undo-buffer.
my_turtle.py:
my_turtle.py:- Some simple commands/methods for creating event driven programs
my_turtle.py:  (mouse-, key-, timer-events). Especially useful for programming games.
my_turtle.py:
my_turtle.py:- A scrollable Canvas class. The default scrollable Canvas can be
my_turtle.py:  extended interactively as needed while playing around with the turtle(s).
my_turtle.py:
my_turtle.py:- A TurtleScreen class with methods controlling background color or
my_turtle.py:  background image, window and canvas size and other properties of the
my_turtle.py:  TurtleScreen.
my_turtle.py:
my_turtle.py:- There is a method, setworldcoordinates(), to install a user defined
my_turtle.py:  coordinate-system for the TurtleScreen.
my_turtle.py:
my_turtle.py:- The implementation uses a 2-vector class named Vec2D, derived from tuple.
my_turtle.py:  This class is public, so it can be imported by the application programmer,
my_turtle.py:  which makes certain types of computations very natural and compact.
my_turtle.py:
my_turtle.py:- Appearance of the TurtleScreen and the Turtles at startup/import can be
my_turtle.py:  configured by means of a turtle.cfg configuration file.
my_turtle.py:  The default configuration mimics the appearance of the old turtle module.
my_turtle.py:
my_turtle.py:- If configured appropriately the module reads in docstrings from a docstring
my_turtle.py:  dictionary in some different language, supplied separately  and replaces
my_turtle.py:  the English ones by those read in. There is a utility function
my_turtle.py:  write_docstringdict() to write a dictionary with the original (English)
my_turtle.py:  docstrings to disc, so it can serve as a template for translations.
my_turtle.py:
my_turtle.py:Behind the scenes there are some features included with possible
my_turtle.py:extensions in mind. These will be commented and documented elsewhere.
my_turtle.py:
my_turtle.py:"""
my_turtle.py:
my_turtle.py:_ver = "turtle 1.1b- - for Python 3.1   -  4. 5. 2009"
my_turtle.py:
my_turtle.py:# print(_ver)
my_turtle.py:
my_turtle.py:import tkinter as TK
my_turtle.py:import types
my_turtle.py:import math
my_turtle.py:import time
my_turtle.py:import inspect
my_turtle.py:import sys
my_turtle.py:
my_turtle.py:from os.path import isfile, split, join
my_turtle.py:from copy import deepcopy
my_turtle.py:from tkinter import simpledialog
my_turtle.py:
my_turtle.py:_tg_classes = ['ScrolledCanvas', 'TurtleScreen', 'Screen',
my_turtle.py:               'RawTurtle', 'Turtle', 'RawPen', 'Pen', 'Shape', 'Vec2D']
my_turtle.py:_tg_screen_functions = ['addshape', 'bgcolor', 'bgpic', 'bye',
my_turtle.py:        'clearscreen', 'colormode', 'delay', 'exitonclick', 'getcanvas',
my_turtle.py:        'getshapes', 'listen', 'mainloop', 'mode', 'numinput',
my_turtle.py:        'onkey', 'onkeypress', 'onkeyrelease', 'onscreenclick', 'ontimer',
my_turtle.py:        'register_shape', 'resetscreen', 'screensize', 'setup',
my_turtle.py:        'setworldcoordinates', 'textinput', 'title', 'tracer', 'turtles', 'update',
my_turtle.py:        'window_height', 'window_width']
my_turtle.py:_tg_turtle_functions = ['back', 'backward', 'begin_fill', 'begin_poly', 'bk',
my_turtle.py:        'circle', 'clear', 'clearstamp', 'clearstamps', 'clone', 'color',
my_turtle.py:        'degrees', 'distance', 'dot', 'down', 'end_fill', 'end_poly', 'fd',
my_turtle.py:        'fillcolor', 'filling', 'forward', 'get_poly', 'getpen', 'getscreen', 'get_shapepoly',
my_turtle.py:        'getturtle', 'goto', 'heading', 'hideturtle', 'home', 'ht', 'isdown',
my_turtle.py:        'isvisible', 'left', 'lt', 'onclick', 'ondrag', 'onrelease', 'pd',
my_turtle.py:        'pen', 'pencolor', 'pendown', 'pensize', 'penup', 'pos', 'position',
my_turtle.py:        'pu', 'radians', 'right', 'reset', 'resizemode', 'rt',
my_turtle.py:        'seth', 'setheading', 'setpos', 'setposition', 'settiltangle',
my_turtle.py:        'setundobuffer', 'setx', 'sety', 'shape', 'shapesize', 'shapetransform', 'shearfactor', 'showturtle',
my_turtle.py:        'speed', 'st', 'stamp', 'tilt', 'tiltangle', 'towards',
my_turtle.py:        'turtlesize', 'undo', 'undobufferentries', 'up', 'width',
my_turtle.py:        'write', 'xcor', 'ycor']
my_turtle.py:_tg_utilities = ['write_docstringdict', 'done']
my_turtle.py:
my_turtle.py:__all__ = (_tg_classes + _tg_screen_functions + _tg_turtle_functions +
my_turtle.py:           _tg_utilities + ['Terminator']) # + _math_functions)
my_turtle.py:
my_turtle.py:_alias_list = ['addshape', 'backward', 'bk', 'fd', 'ht', 'lt', 'pd', 'pos',
my_turtle.py:               'pu', 'rt', 'seth', 'setpos', 'setposition', 'st',
my_turtle.py:               'turtlesize', 'up', 'width']
my_turtle.py:
my_turtle.py:_CFG = {"width" : 0.5,               # Screen
my_turtle.py:        "height" : 0.75,
my_turtle.py:        "canvwidth" : 400,
my_turtle.py:        "canvheight": 300,
my_turtle.py:        "leftright": None,
my_turtle.py:        "topbottom": None,
my_turtle.py:        "mode": "standard",          # TurtleScreen
my_turtle.py:        "colormode": 1.0,
my_turtle.py:        "delay": 10,
my_turtle.py:        "undobuffersize": 1000,      # RawTurtle
my_turtle.py:        "shape": "classic",
my_turtle.py:        "pencolor" : "black",
my_turtle.py:        "fillcolor" : "black",
my_turtle.py:        "resizemode" : "noresize",
my_turtle.py:        "visible" : True,
my_turtle.py:        "language": "english",        # docstrings
my_turtle.py:        "exampleturtle": "turtle",
my_turtle.py:        "examplescreen": "screen",
my_turtle.py:        "title": "Python Turtle Graphics",
my_turtle.py:        "using_IDLE": False
my_turtle.py:       }
my_turtle.py:
my_turtle.py:def config_dict(filename):
my_turtle.py:    """Convert content of config-file into dictionary."""
my_turtle.py:    with open(filename, "r") as f:
my_turtle.py:        cfglines = f.readlines()
my_turtle.py:    cfgdict = {}
my_turtle.py:    for line in cfglines:
my_turtle.py:        line = line.strip()
my_turtle.py:        if not line or line.startswith("#"):
my_turtle.py:            continue
my_turtle.py:        try:
my_turtle.py:            key, value = line.split("=")
my_turtle.py:        except:
my_turtle.py:            print("Bad line in config-file %s:\n%s" % (filename,line))
my_turtle.py:            continue
my_turtle.py:        key = key.strip()
my_turtle.py:        value = value.strip()
my_turtle.py:        if value in ["True", "False", "None", "''", '""']:
my_turtle.py:            value = eval(value)
my_turtle.py:        else:
my_turtle.py:            try:
my_turtle.py:                if "." in value:
my_turtle.py:                    value = float(value)
my_turtle.py:                else:
my_turtle.py:                    value = int(value)
my_turtle.py:            except:
my_turtle.py:                pass # value need not be converted
my_turtle.py:        cfgdict[key] = value
my_turtle.py:    return cfgdict
my_turtle.py:
my_turtle.py:def readconfig(cfgdict):
my_turtle.py:    """Read config-files, change configuration-dict accordingly.
my_turtle.py:
my_turtle.py:    If there is a turtle.cfg file in the current working directory,
my_turtle.py:    read it from there. If this contains an importconfig-value,
my_turtle.py:    say 'myway', construct filename turtle_mayway.cfg else use
my_turtle.py:    turtle.cfg and read it from the import-directory, where
my_turtle.py:    turtle.py is located.
my_turtle.py:    Update configuration dictionary first according to config-file,
my_turtle.py:    in the import directory, then according to config-file in the
my_turtle.py:    current working directory.
my_turtle.py:    If no config-file is found, the default configuration is used.
my_turtle.py:    """
my_turtle.py:    default_cfg = "turtle.cfg"
my_turtle.py:    cfgdict1 = {}
my_turtle.py:    cfgdict2 = {}
my_turtle.py:    if isfile(default_cfg):
my_turtle.py:        cfgdict1 = config_dict(default_cfg)
my_turtle.py:    if "importconfig" in cfgdict1:
my_turtle.py:        default_cfg = "turtle_%s.cfg" % cfgdict1["importconfig"]
my_turtle.py:    try:
my_turtle.py:        head, tail = split(__file__)
my_turtle.py:        cfg_file2 = join(head, default_cfg)
my_turtle.py:    except:
my_turtle.py:        cfg_file2 = ""
my_turtle.py:    if isfile(cfg_file2):
my_turtle.py:        cfgdict2 = config_dict(cfg_file2)
my_turtle.py:    _CFG.update(cfgdict2)
my_turtle.py:    _CFG.update(cfgdict1)
my_turtle.py:
my_turtle.py:try:
my_turtle.py:    readconfig(_CFG)
my_turtle.py:except:
my_turtle.py:    print ("No configfile read, reason unknown")
my_turtle.py:
my_turtle.py:
my_turtle.py:class Vec2D(tuple):
my_turtle.py:    """A 2 dimensional vector class, used as a helper class
my_turtle.py:    for implementing turtle graphics.
my_turtle.py:    May be useful for turtle graphics programs also.
my_turtle.py:    Derived from tuple, so a vector is a tuple!
my_turtle.py:
my_turtle.py:    Provides (for a, b vectors, k number):
my_turtle.py:       a+b vector addition
my_turtle.py:       a-b vector subtraction
my_turtle.py:       a*b inner product
my_turtle.py:       k*a and a*k multiplication with scalar
my_turtle.py:       |a| absolute value of a
my_turtle.py:       a.rotate(angle) rotation
my_turtle.py:    """
my_turtle.py:    def __new__(cls, x, y):
my_turtle.py:        return tuple.__new__(cls, (x, y))
my_turtle.py:    def __add__(self, other):
my_turtle.py:        return Vec2D(self[0]+other[0], self[1]+other[1])
my_turtle.py:    def __mul__(self, other):
my_turtle.py:        if isinstance(other, Vec2D):
my_turtle.py:            return self[0]*other[0]+self[1]*other[1]
my_turtle.py:        return Vec2D(self[0]*other, self[1]*other)
my_turtle.py:    def __rmul__(self, other):
my_turtle.py:        if isinstance(other, int) or isinstance(other, float):
my_turtle.py:            return Vec2D(self[0]*other, self[1]*other)
my_turtle.py:    def __sub__(self, other):
my_turtle.py:        return Vec2D(self[0]-other[0], self[1]-other[1])
my_turtle.py:    def __neg__(self):
my_turtle.py:        return Vec2D(-self[0], -self[1])
my_turtle.py:    def __abs__(self):
my_turtle.py:        return (self[0]**2 + self[1]**2)**0.5
my_turtle.py:    def rotate(self, angle):
my_turtle.py:        """rotate self counterclockwise by angle
my_turtle.py:        """
my_turtle.py:        perp = Vec2D(-self[1], self[0])
my_turtle.py:        angle = angle * math.pi / 180.0
my_turtle.py:        c, s = math.cos(angle), math.sin(angle)
my_turtle.py:        return Vec2D(self[0]*c+perp[0]*s, self[1]*c+perp[1]*s)
my_turtle.py:    def __getnewargs__(self):
my_turtle.py:        return (self[0], self[1])
my_turtle.py:    def __repr__(self):
my_turtle.py:        return "(%.2f,%.2f)" % self
my_turtle.py:
my_turtle.py:
my_turtle.py:##############################################################################
my_turtle.py:### From here up to line    : Tkinter - Interface for turtle.py            ###
my_turtle.py:### May be replaced by an interface to some different graphics toolkit     ###
my_turtle.py:##############################################################################
my_turtle.py:
my_turtle.py:## helper functions for Scrolled Canvas, to forward Canvas-methods
my_turtle.py:## to ScrolledCanvas class
my_turtle.py:
my_turtle.py:def __methodDict(cls, _dict):
my_turtle.py:    """helper function for Scrolled Canvas"""
my_turtle.py:    baseList = list(cls.__bases__)
my_turtle.py:    baseList.reverse()
my_turtle.py:    for _super in baseList:
my_turtle.py:        __methodDict(_super, _dict)
my_turtle.py:    for key, value in cls.__dict__.items():
my_turtle.py:        if type(value) == types.FunctionType:
my_turtle.py:            _dict[key] = value
my_turtle.py:
my_turtle.py:def __methods(cls):
my_turtle.py:    """helper function for Scrolled Canvas"""
my_turtle.py:    _dict = {}
my_turtle.py:    __methodDict(cls, _dict)
my_turtle.py:    return _dict.keys()
my_turtle.py:
my_turtle.py:__stringBody = (
my_turtle.py:    'def %(method)s(self, *args, **kw): return ' +
my_turtle.py:    'self.%(attribute)s.%(method)s(*args, **kw)')
my_turtle.py:
my_turtle.py:def __forwardmethods(fromClass, toClass, toPart, exclude = ()):
my_turtle.py:    ### MANY CHANGES ###
my_turtle.py:    _dict_1 = {}
my_turtle.py:    __methodDict(toClass, _dict_1)
my_turtle.py:    _dict = {}
my_turtle.py:    mfc = __methods(fromClass)
my_turtle.py:    for ex in _dict_1.keys():
my_turtle.py:        if ex[:1] == '_' or ex[-1:] == '_' or ex in exclude or ex in mfc:
my_turtle.py:            pass
my_turtle.py:        else:
my_turtle.py:            _dict[ex] = _dict_1[ex]
my_turtle.py:
my_turtle.py:    for method, func in _dict.items():
my_turtle.py:        d = {'method': method, 'func': func}
my_turtle.py:        if isinstance(toPart, str):
my_turtle.py:            execString = \
my_turtle.py:                __stringBody % {'method' : method, 'attribute' : toPart}
my_turtle.py:        exec(execString, d)
my_turtle.py:        setattr(fromClass, method, d[method])   ### NEWU!
my_turtle.py:
my_turtle.py:
my_turtle.py:class ScrolledCanvas(TK.Frame):
my_turtle.py:    """Modeled after the scrolled canvas class from Grayons's Tkinter book.
my_turtle.py:
my_turtle.py:    Used as the default canvas, which pops up automatically when
my_turtle.py:    using turtle graphics functions or the Turtle class.
my_turtle.py:    """
my_turtle.py:    def __init__(self, master, width=500, height=350,
my_turtle.py:                                          canvwidth=600, canvheight=500):
my_turtle.py:        TK.Frame.__init__(self, master, width=width, height=height)
my_turtle.py:        self._rootwindow = self.winfo_toplevel()
my_turtle.py:        self.width, self.height = width, height
my_turtle.py:        self.canvwidth, self.canvheight = canvwidth, canvheight
my_turtle.py:        self.bg = "white"
my_turtle.py:        self._canvas = TK.Canvas(master, width=width, height=height,
my_turtle.py:                                 bg=self.bg, relief=TK.SUNKEN, borderwidth=2)
my_turtle.py:        self.hscroll = TK.Scrollbar(master, command=self._canvas.xview,
my_turtle.py:                                    orient=TK.HORIZONTAL)
my_turtle.py:        self.vscroll = TK.Scrollbar(master, command=self._canvas.yview)
my_turtle.py:        self._canvas.configure(xscrollcommand=self.hscroll.set,
my_turtle.py:                               yscrollcommand=self.vscroll.set)
my_turtle.py:        self.rowconfigure(0, weight=1, minsize=0)
my_turtle.py:        self.columnconfigure(0, weight=1, minsize=0)
my_turtle.py:        self._canvas.grid(padx=1, in_ = self, pady=1, row=0,
my_turtle.py:                column=0, rowspan=1, columnspan=1, sticky='news')
my_turtle.py:        self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
my_turtle.py:                column=1, rowspan=1, columnspan=1, sticky='news')
my_turtle.py:        self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
my_turtle.py:                column=0, rowspan=1, columnspan=1, sticky='news')
my_turtle.py:        self.reset()
my_turtle.py:        self._rootwindow.bind('<Configure>', self.onResize)
my_turtle.py:
my_turtle.py:    def reset(self, canvwidth=None, canvheight=None, bg = None):
my_turtle.py:        """Adjust canvas and scrollbars according to given canvas size."""
my_turtle.py:        if canvwidth:
my_turtle.py:            self.canvwidth = canvwidth
my_turtle.py:        if canvheight:
my_turtle.py:            self.canvheight = canvheight
my_turtle.py:        if bg:
my_turtle.py:            self.bg = bg
my_turtle.py:        self._canvas.config(bg=bg,
my_turtle.py:                        scrollregion=(-self.canvwidth//2, -self.canvheight//2,
my_turtle.py:                                       self.canvwidth//2, self.canvheight//2))
my_turtle.py:        self._canvas.xview_moveto(0.5*(self.canvwidth - self.width + 30) /
my_turtle.py:                                                               self.canvwidth)
my_turtle.py:        self._canvas.yview_moveto(0.5*(self.canvheight- self.height + 30) /
my_turtle.py:                                                              self.canvheight)
my_turtle.py:        self.adjustScrolls()
my_turtle.py:
my_turtle.py:
my_turtle.py:    def adjustScrolls(self):
my_turtle.py:        """ Adjust scrollbars according to window- and canvas-size.
my_turtle.py:        """
my_turtle.py:        cwidth = self._canvas.winfo_width()
my_turtle.py:        cheight = self._canvas.winfo_height()
my_turtle.py:        self._canvas.xview_moveto(0.5*(self.canvwidth-cwidth)/self.canvwidth)
my_turtle.py:        self._canvas.yview_moveto(0.5*(self.canvheight-cheight)/self.canvheight)
my_turtle.py:        if cwidth < self.canvwidth or cheight < self.canvheight:
my_turtle.py:            self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
my_turtle.py:                              column=0, rowspan=1, columnspan=1, sticky='news')
my_turtle.py:            self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
my_turtle.py:                              column=1, rowspan=1, columnspan=1, sticky='news')
my_turtle.py:        else:
my_turtle.py:            self.hscroll.grid_forget()
my_turtle.py:            self.vscroll.grid_forget()
my_turtle.py:
my_turtle.py:    def onResize(self, event):
my_turtle.py:        """self-explanatory"""
my_turtle.py:        self.adjustScrolls()
my_turtle.py:
my_turtle.py:    def bbox(self, *args):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        return self._canvas.bbox(*args)
my_turtle.py:
my_turtle.py:    def cget(self, *args, **kwargs):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        return self._canvas.cget(*args, **kwargs)
my_turtle.py:
my_turtle.py:    def config(self, *args, **kwargs):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        self._canvas.config(*args, **kwargs)
my_turtle.py:
my_turtle.py:    def bind(self, *args, **kwargs):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        self._canvas.bind(*args, **kwargs)
my_turtle.py:
my_turtle.py:    def unbind(self, *args, **kwargs):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        self._canvas.unbind(*args, **kwargs)
my_turtle.py:
my_turtle.py:    def focus_force(self):
my_turtle.py:        """ 'forward' method, which canvas itself has inherited...
my_turtle.py:        """
my_turtle.py:        self._canvas.focus_force()
my_turtle.py:
my_turtle.py:__forwardmethods(ScrolledCanvas, TK.Canvas, '_canvas')
my_turtle.py:
my_turtle.py:
my_turtle.py:class _Root(TK.Tk):
my_turtle.py:    """Root class for Screen based on Tkinter."""
my_turtle.py:    def __init__(self):
my_turtle.py:        TK.Tk.__init__(self)
my_turtle.py:
my_turtle.py:    def setupcanvas(self, width, height, cwidth, cheight):
my_turtle.py:        self._canvas = ScrolledCanvas(self, width, height, cwidth, cheight)
my_turtle.py:        self._canvas.pack(expand=1, fill="both")
my_turtle.py:
my_turtle.py:    def _getcanvas(self):
my_turtle.py:        return self._canvas
my_turtle.py:
my_turtle.py:    def set_geometry(self, width, height, startx, starty):
my_turtle.py:        self.geometry("%dx%d%+d%+d"%(width, height, startx, starty))
my_turtle.py:
my_turtle.py:    def ondestroy(self, destroy):
my_turtle.py:        self.wm_protocol("WM_DELETE_WINDOW", destroy)
my_turtle.py:
my_turtle.py:    def win_width(self):
my_turtle.py:        return self.winfo_screenwidth()
my_turtle.py:
my_turtle.py:    def win_height(self):
my_turtle.py:        return self.winfo_screenheight()
my_turtle.py:
my_turtle.py:Canvas = TK.Canvas
my_turtle.py:
my_turtle.py:
my_turtle.py:class TurtleScreenBase(object):
my_turtle.py:    """Provide the basic graphics functionality.
my_turtle.py:       Interface between Tkinter and turtle.py.
my_turtle.py:
my_turtle.py:       To port turtle.py to some different graphics toolkit
my_turtle.py:       a corresponding TurtleScreenBase class has to be implemented.
my_turtle.py:    """
my_turtle.py:
my_turtle.py:    @staticmethod
my_turtle.py:    def _blankimage():
my_turtle.py:        """return a blank image object
my_turtle.py:        """
my_turtle.py:        img = TK.PhotoImage(width=1, height=1)
my_turtle.py:        img.blank()
my_turtle.py:        return img
my_turtle.py:
my_turtle.py:    @staticmethod
my_turtle.py:    def _image(filename):
my_turtle.py:        """return an image object containing the
my_turtle.py:        imagedata from a gif-file named filename.
my_turtle.py:        """
my_turtle.py:        return TK.PhotoImage(file=filename)
my_turtle.py:
my_turtle.py:    def __init__(self, cv):
my_turtle.py:        self.cv = cv
my_turtle.py:        if isinstance(cv, ScrolledCanvas):
my_turtle.py:            w = self.cv.canvwidth
my_turtle.py:            h = self.cv.canvheight
my_turtle.py:        else:  # expected: ordinary TK.Canvas
my_turtle.py:            w = int(self.cv.cget("width"))
my_turtle.py:            h = int(self.cv.cget("height"))
my_turtle.py:            self.cv.config(scrollregion = (-w//2, -h//2, w//2, h//2 ))
my_turtle.py:        self.canvwidth = w
my_turtle.py:        self.canvheight = h
my_turtle.py:        self.xscale = self.yscale = 1.0
my_turtle.py:
my_turtle.py:    def _createpoly(self):
my_turtle.py:        """Create an invisible polygon item on canvas self.cv)
my_turtle.py:        """
my_turtle.py:        return self.cv.create_polygon((0, 0, 0, 0, 0, 0), fill="", outline="")
my_turtle.py:
my_turtle.py:    def _drawpoly(self, polyitem, coordlist, fill=None,
my_turtle.py:                  outline=None, width=None, top=False):
my_turtle.py:        """Configure polygonitem polyitem according to provided
my_turtle.py:        arguments:
my_turtle.py:        coordlist is sequence of coordinates
my_turtle.py:        fill is filling color
my_turtle.py:        outline is outline color
my_turtle.py:        top is a boolean value, which specifies if polyitem
my_turtle.py:        will be put on top of the canvas' displaylist so it
my_turtle.py:        will not be covered by other items.
my_turtle.py:        """
my_turtle.py:        cl = []
my_turtle.py:        for x, y in coordlist:
my_turtle.py:            cl.append(x * self.xscale)
my_turtle.py:            cl.append(-y * self.yscale)
my_turtle.py:        self.cv.coords(polyitem, *cl)
my_turtle.py:        if fill is not None:
my_turtle.py:            self.cv.itemconfigure(polyitem, fill=fill)
my_turtle.py:        if outline is not None:
my_turtle.py:            self.cv.itemconfigure(polyitem, outline=outline)
my_turtle.py:        if width is not None:
my_turtle.py:            self.cv.itemconfigure(polyitem, width=width)
my_turtle.py:        if top:
my_turtle.py:            self.cv.tag_raise(polyitem)
my_turtle.py:
my_turtle.py:    def _createline(self):
my_turtle.py:        """Create an invisible line item on canvas self.cv)
my_turtle.py:        """
my_turtle.py:        return self.cv.create_line(0, 0, 0, 0, fill="", width=2,
my_turtle.py:                                   capstyle = TK.ROUND)
my_turtle.py:
my_turtle.py:    def _drawline(self, lineitem, coordlist=None,
my_turtle.py:                  fill=None, width=None, top=False):
my_turtle.py:        """Configure lineitem according to provided arguments:
my_turtle.py:        coordlist is sequence of coordinates
my_turtle.py:        fill is drawing color
my_turtle.py:        width is width of drawn line.
my_turtle.py:        top is a boolean value, which specifies if polyitem
my_turtle.py:        will be put on top of the canvas' displaylist so it
my_turtle.py:        will not be covered by other items.
my_turtle.py:        """
my_turtle.py:        if coordlist is not None:
my_turtle.py:            cl = []
my_turtle.py:            for x, y in coordlist:
my_turtle.py:                cl.append(x * self.xscale)
my_turtle.py:                cl.append(-y * self.yscale)
my_turtle.py:            self.cv.coords(lineitem, *cl)
my_turtle.py:        if fill is not None:
my_turtle.py:            self.cv.itemconfigure(lineitem, fill=fill)
my_turtle.py:        if width is not None:
my_turtle.py:            self.cv.itemconfigure(lineitem, width=width)
my_turtle.py:        if top:
my_turtle.py:            self.cv.tag_raise(lineitem)
my_turtle.py:
my_turtle.py:    def _delete(self, item):
my_turtle.py:        """Delete graphics item from canvas.
my_turtle.py:        If item is"all" delete all graphics items.
my_turtle.py:        """
my_turtle.py:        self.cv.delete(item)
my_turtle.py:
my_turtle.py:    def _update(self):
my_turtle.py:        """Redraw graphics items on canvas
my_turtle.py:        """
my_turtle.py:        self.cv.update()
my_turtle.py:
my_turtle.py:    def _delay(self, delay):
my_turtle.py:        """Delay subsequent canvas actions for delay ms."""
my_turtle.py:        self.cv.after(delay)
my_turtle.py:
my_turtle.py:    def _iscolorstring(self, color):
my_turtle.py:        """Check if the string color is a legal Tkinter color string.
my_turtle.py:        """
my_turtle.py:        try:
my_turtle.py:            rgb = self.cv.winfo_rgb(color)
my_turtle.py:            ok = True
my_turtle.py:        except TK.TclError:
my_turtle.py:            ok = False
my_turtle.py:        return ok
my_turtle.py:
my_turtle.py:    def _bgcolor(self, color=None):
my_turtle.py:        """Set canvas' backgroundcolor if color is not None,
my_turtle.py:        else return backgroundcolor."""
my_turtle.py:        if color is not None:
my_turtle.py:            self.cv.config(bg = color)
my_turtle.py:            self._update()
my_turtle.py:        else:
my_turtle.py:            return self.cv.cget("bg")
my_turtle.py:
my_turtle.py:    def _write(self, pos, txt, align, font, pencolor):
my_turtle.py:        """Write txt at pos in canvas with specified font
my_turtle.py:        and color.
my_turtle.py:        Return text item and x-coord of right bottom corner
my_turtle.py:        of text's bounding box."""
my_turtle.py:        x, y = pos
my_turtle.py:        x = x * self.xscale
my_turtle.py:        y = y * self.yscale
my_turtle.py:        anchor = {"left":"sw", "center":"s", "right":"se" }
my_turtle.py:        item = self.cv.create_text(x-1, -y, text = txt, anchor = anchor[align],
my_turtle.py:                                        fill = pencolor, font = font)
my_turtle.py:        x0, y0, x1, y1 = self.cv.bbox(item)
my_turtle.py:        self.cv.update()
my_turtle.py:        return item, x1-1
my_turtle.py:
my_turtle.py:##    def _dot(self, pos, size, color):
my_turtle.py:##        """may be implemented for some other graphics toolkit"""
my_turtle.py:
my_turtle.py:    def _onclick(self, item, fun, num=1, add=None):
my_turtle.py:        """Bind fun to mouse-click event on turtle.
my_turtle.py:        fun must be a function with two arguments, the coordinates
my_turtle.py:        of the clicked point on the canvas.
my_turtle.py:        num, the number of the mouse-button defaults to 1
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            self.cv.tag_unbind(item, "<Button-%s>" % num)
my_turtle.py:        else:
my_turtle.py:            def eventfun(event):
my_turtle.py:                x, y = (self.cv.canvasx(event.x)/self.xscale,
my_turtle.py:                        -self.cv.canvasy(event.y)/self.yscale)
my_turtle.py:                fun(x, y)
my_turtle.py:            self.cv.tag_bind(item, "<Button-%s>" % num, eventfun, add)
my_turtle.py:
my_turtle.py:    def _onrelease(self, item, fun, num=1, add=None, args=None):
my_turtle.py:        """Bind fun to mouse-button-release event on turtle.
my_turtle.py:        fun must be a function with two arguments, the coordinates
my_turtle.py:        of the point on the canvas where mouse button is released.
my_turtle.py:        num, the number of the mouse-button defaults to 1
my_turtle.py:
my_turtle.py:        If a turtle is clicked, first _onclick-event will be performed,
my_turtle.py:        then _onscreensclick-event.
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            self.cv.tag_unbind(item, "<Button%s-ButtonRelease>" % num)
my_turtle.py:        else:
my_turtle.py:            if not(args is None):
my_turtle.py:                def eventfun(event):
my_turtle.py:                    fun(args)
my_turtle.py:            else:
my_turtle.py:                def eventfun(event):
my_turtle.py:                    x, y = (self.cv.canvasx(event.x)/self.xscale,
my_turtle.py:                            -self.cv.canvasy(event.y)/self.yscale)
my_turtle.py:                    fun(x, y)
my_turtle.py:            self.cv.tag_bind(item, "<Button%s-ButtonRelease>" % num,
my_turtle.py:                             eventfun, add)
my_turtle.py:
my_turtle.py:    def _ondrag(self, item, fun, num=1, add=None):
my_turtle.py:        """Bind fun to mouse-move-event (with pressed mouse button) on turtle.
my_turtle.py:        fun must be a function with two arguments, the coordinates of the
my_turtle.py:        actual mouse position on the canvas.
my_turtle.py:        num, the number of the mouse-button defaults to 1
my_turtle.py:
my_turtle.py:        Every sequence of mouse-move-events on a turtle is preceded by a
my_turtle.py:        mouse-click event on that turtle.
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            self.cv.tag_unbind(item, "<Button%s-Motion>" % num)
my_turtle.py:        else:
my_turtle.py:            def eventfun(event):
my_turtle.py:                try:
my_turtle.py:                    x, y = (self.cv.canvasx(event.x)/self.xscale,
my_turtle.py:                           -self.cv.canvasy(event.y)/self.yscale)
my_turtle.py:                    fun(x, y)
my_turtle.py:                except:
my_turtle.py:                    pass
my_turtle.py:            self.cv.tag_bind(item, "<Button%s-Motion>" % num, eventfun, add)
my_turtle.py:
my_turtle.py:    def _onscreenclick(self, fun, num=1, add=None, args=None):
my_turtle.py:        """Bind fun to mouse-click event on canvas.
my_turtle.py:        fun must be a function with two arguments, the coordinates
my_turtle.py:        of the clicked point on the canvas.
my_turtle.py:        num, the number of the mouse-button defaults to 1
my_turtle.py:
my_turtle.py:        If a turtle is clicked, first _onclick-event will be performed,
my_turtle.py:        then _onscreensclick-event.
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            self.cv.unbind("<Button-%s>" % num)
my_turtle.py:        else:
my_turtle.py:            def eventfun(event):
my_turtle.py:                x, y = (self.cv.canvasx(event.x)/self.xscale,
my_turtle.py:                        -self.cv.canvasy(event.y)/self.yscale)
my_turtle.py:                fun(x, y)
my_turtle.py:            self.cv.bind("<Button-%s>" % num, eventfun, add)
my_turtle.py:
my_turtle.py:    def _onkeyrelease(self, fun, key):
my_turtle.py:        """Bind fun to key-release event of key.
my_turtle.py:        Canvas must have focus. See method listen
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            self.cv.unbind("<KeyRelease-%s>" % key, None)
my_turtle.py:        else:
my_turtle.py:            def eventfun(event):
my_turtle.py:                fun()
my_turtle.py:            self.cv.bind("<KeyRelease-%s>" % key, eventfun)
my_turtle.py:
my_turtle.py:    def _onkeypress(self, fun, key=None):
my_turtle.py:        """If key is given, bind fun to key-press event of key.
my_turtle.py:        Otherwise bind fun to any key-press.
my_turtle.py:        Canvas must have focus. See method listen.
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            if key is None:
my_turtle.py:                self.cv.unbind("<KeyPress>", None)
my_turtle.py:            else:
my_turtle.py:                self.cv.unbind("<KeyPress-%s>" % key, None)
my_turtle.py:        else:
my_turtle.py:            def eventfun(event):
my_turtle.py:                fun()
my_turtle.py:            if key is None:
my_turtle.py:                self.cv.bind("<KeyPress>", eventfun)
my_turtle.py:            else:
my_turtle.py:                self.cv.bind("<KeyPress-%s>" % key, eventfun)
my_turtle.py:
my_turtle.py:    def _listen(self):
my_turtle.py:        """Set focus on canvas (in order to collect key-events)
my_turtle.py:        """
my_turtle.py:        self.cv.focus_force()
my_turtle.py:
my_turtle.py:    def _ontimer(self, fun, t):
my_turtle.py:        """Install a timer, which calls fun after t milliseconds.
my_turtle.py:        """
my_turtle.py:        if t == 0:
my_turtle.py:            self.cv.after_idle(fun)
my_turtle.py:        else:
my_turtle.py:            self.cv.after(t, fun)
my_turtle.py:
my_turtle.py:    def _createimage(self, image):
my_turtle.py:        """Create and return image item on canvas.
my_turtle.py:        """
my_turtle.py:        return self.cv.create_image(0, 0, image=image)
my_turtle.py:
my_turtle.py:    def _drawimage(self, item, pos, image):
my_turtle.py:        """Configure image item as to draw image object
my_turtle.py:        at position (x,y) on canvas)
my_turtle.py:        """
my_turtle.py:        x, y = pos
my_turtle.py:        self.cv.coords(item, (x * self.xscale, -y * self.yscale))
my_turtle.py:        self.cv.itemconfig(item, image=image)
my_turtle.py:
my_turtle.py:    def _setbgpic(self, item, image):
my_turtle.py:        """Configure image item as to draw image object
my_turtle.py:        at center of canvas. Set item to the first item
my_turtle.py:        in the displaylist, so it will be drawn below
my_turtle.py:        any other item ."""
my_turtle.py:        self.cv.itemconfig(item, image=image)
my_turtle.py:        self.cv.tag_lower(item)
my_turtle.py:
my_turtle.py:    def _type(self, item):
my_turtle.py:        """Return 'line' or 'polygon' or 'image' depending on
my_turtle.py:        type of item.
my_turtle.py:        """
my_turtle.py:        return self.cv.type(item)
my_turtle.py:
my_turtle.py:    def _pointlist(self, item):
my_turtle.py:        """returns list of coordinate-pairs of points of item
my_turtle.py:        Example (for insiders):
my_turtle.py:        >>> from turtle import *
my_turtle.py:        >>> getscreen()._pointlist(getturtle().turtle._item)
my_turtle.py:        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),
my_turtle.py:        (9.9999999999999982, 0.0)]
my_turtle.py:        >>> """
my_turtle.py:        cl = self.cv.coords(item)
my_turtle.py:        pl = [(cl[i], -cl[i+1]) for i in range(0, len(cl), 2)]
my_turtle.py:        return  pl
my_turtle.py:
my_turtle.py:    def _setscrollregion(self, srx1, sry1, srx2, sry2):
my_turtle.py:        self.cv.config(scrollregion=(srx1, sry1, srx2, sry2))
my_turtle.py:
my_turtle.py:    def _rescale(self, xscalefactor, yscalefactor):
my_turtle.py:        items = self.cv.find_all()
my_turtle.py:        for item in items:
my_turtle.py:            coordinates = list(self.cv.coords(item))
my_turtle.py:            newcoordlist = []
my_turtle.py:            while coordinates:
my_turtle.py:                x, y = coordinates[:2]
my_turtle.py:                newcoordlist.append(x * xscalefactor)
my_turtle.py:                newcoordlist.append(y * yscalefactor)
my_turtle.py:                coordinates = coordinates[2:]
my_turtle.py:            self.cv.coords(item, *newcoordlist)
my_turtle.py:
my_turtle.py:    def _resize(self, canvwidth=None, canvheight=None, bg=None):
my_turtle.py:        """Resize the canvas the turtles are drawing on. Does
my_turtle.py:        not alter the drawing window.
my_turtle.py:        """
my_turtle.py:        # needs amendment
my_turtle.py:        if not isinstance(self.cv, ScrolledCanvas):
my_turtle.py:            return self.canvwidth, self.canvheight
my_turtle.py:        if canvwidth is canvheight is bg is None:
my_turtle.py:            return self.cv.canvwidth, self.cv.canvheight
my_turtle.py:        if canvwidth is not None:
my_turtle.py:            self.canvwidth = canvwidth
my_turtle.py:        if canvheight is not None:
my_turtle.py:            self.canvheight = canvheight
my_turtle.py:        self.cv.reset(canvwidth, canvheight, bg)
my_turtle.py:
my_turtle.py:    def _window_size(self):
my_turtle.py:        """ Return the width and height of the turtle window.
my_turtle.py:        """
my_turtle.py:        width = self.cv.winfo_width()
my_turtle.py:        if width <= 1:  # the window isn't managed by a geometry manager
my_turtle.py:            width = self.cv['width']
my_turtle.py:        height = self.cv.winfo_height()
my_turtle.py:        if height <= 1: # the window isn't managed by a geometry manager
my_turtle.py:            height = self.cv['height']
my_turtle.py:        return width, height
my_turtle.py:
my_turtle.py:    def mainloop(self):
my_turtle.py:        """Starts event loop - calling Tkinter's mainloop function.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Must be last statement in a turtle graphics program.
my_turtle.py:        Must NOT be used if a script is run from within IDLE in -n mode
my_turtle.py:        (No subprocess) - for interactive use of turtle graphics.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.mainloop()
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        TK.mainloop()
my_turtle.py:
my_turtle.py:    def textinput(self, title, prompt):
my_turtle.py:        """Pop up a dialog window for input of a string.
my_turtle.py:
my_turtle.py:        Arguments: title is the title of the dialog window,
my_turtle.py:        prompt is a text mostly describing what information to input.
my_turtle.py:
my_turtle.py:        Return the string input
my_turtle.py:        If the dialog is canceled, return None.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.textinput("NIM", "Name of first player:")
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        return simpledialog.askstring(title, prompt)
my_turtle.py:
my_turtle.py:    def numinput(self, title, prompt, default=None, minval=None, maxval=None):
my_turtle.py:        """Pop up a dialog window for input of a number.
my_turtle.py:
my_turtle.py:        Arguments: title is the title of the dialog window,
my_turtle.py:        prompt is a text mostly describing what numerical information to input.
my_turtle.py:        default: default value
my_turtle.py:        minval: minimum value for imput
my_turtle.py:        maxval: maximum value for input
my_turtle.py:
my_turtle.py:        The number input must be in the range minval .. maxval if these are
my_turtle.py:        given. If not, a hint is issued and the dialog remains open for
my_turtle.py:        correction. Return the number input.
my_turtle.py:        If the dialog is canceled,  return None.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.numinput("Poker", "Your stakes:", 1000, minval=10, maxval=10000)
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        return simpledialog.askfloat(title, prompt, initialvalue=default,
my_turtle.py:                                     minvalue=minval, maxvalue=maxval)
my_turtle.py:
my_turtle.py:
my_turtle.py:##############################################################################
my_turtle.py:###                  End of Tkinter - interface                            ###
my_turtle.py:##############################################################################
my_turtle.py:
my_turtle.py:
my_turtle.py:class Terminator (Exception):
my_turtle.py:    """Will be raised in TurtleScreen.update, if _RUNNING becomes False.
my_turtle.py:
my_turtle.py:    This stops execution of a turtle graphics script.
my_turtle.py:    Main purpose: use in the Demo-Viewer turtle.Demo.py.
my_turtle.py:    """
my_turtle.py:    pass
my_turtle.py:
my_turtle.py:
my_turtle.py:class TurtleGraphicsError(Exception):
my_turtle.py:    """Some TurtleGraphics Error
my_turtle.py:    """
my_turtle.py:
my_turtle.py:
my_turtle.py:class Shape(object):
my_turtle.py:    """Data structure modeling shapes.
my_turtle.py:
my_turtle.py:    attribute _type is one of "polygon", "image", "compound"
my_turtle.py:    attribute _data is - depending on _type a poygon-tuple,
my_turtle.py:    an image or a list constructed using the addcomponent method.
my_turtle.py:    """
my_turtle.py:    def __init__(self, type_, data=None):
my_turtle.py:        self._type = type_
my_turtle.py:        if type_ == "polygon":
my_turtle.py:            if isinstance(data, list):
my_turtle.py:                data = tuple(data)
my_turtle.py:        elif type_ == "image":
my_turtle.py:            if isinstance(data, str):
my_turtle.py:                if data.casefold().endswith(".gif") and isfile(data):
my_turtle.py:                    data = TurtleScreen._image(data)
my_turtle.py:                # else data assumed to be Photoimage
my_turtle.py:        elif type_ == "compound":
my_turtle.py:            data = []
my_turtle.py:        else:
my_turtle.py:            raise TurtleGraphicsError("There is no shape type %s" % type_)
my_turtle.py:        self._data = data
my_turtle.py:
my_turtle.py:    def addcomponent(self, poly, fill, outline=None):
my_turtle.py:        """Add component to a shape of type compound.
my_turtle.py:
my_turtle.py:        Arguments: poly is a polygon, i. e. a tuple of number pairs.
my_turtle.py:        fill is the fillcolor of the component,
my_turtle.py:        outline is the outline color of the component.
my_turtle.py:
my_turtle.py:        call (for a Shapeobject namend s):
my_turtle.py:        --   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")
my_turtle.py:
my_turtle.py:        Example:
my_turtle.py:        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
my_turtle.py:        >>> s = Shape("compound")
my_turtle.py:        >>> s.addcomponent(poly, "red", "blue")
my_turtle.py:        >>> # .. add more components and then use register_shape()
my_turtle.py:        """
my_turtle.py:        if self._type != "compound":
my_turtle.py:            raise TurtleGraphicsError("Cannot add component to %s Shape"
my_turtle.py:                                                                % self._type)
my_turtle.py:        if outline is None:
my_turtle.py:            outline = fill
my_turtle.py:        self._data.append([poly, fill, outline])
my_turtle.py:
my_turtle.py:
my_turtle.py:class Tbuffer(object):
my_turtle.py:    """Ring buffer used as undobuffer for RawTurtle objects."""
my_turtle.py:    def __init__(self, bufsize=10):
my_turtle.py:        self.bufsize = bufsize
my_turtle.py:        self.buffer = [[None]] * bufsize
my_turtle.py:        self.ptr = -1
my_turtle.py:        self.cumulate = False
my_turtle.py:    def reset(self, bufsize=None):
my_turtle.py:        if bufsize is None:
my_turtle.py:            for i in range(self.bufsize):
my_turtle.py:                self.buffer[i] = [None]
my_turtle.py:        else:
my_turtle.py:            self.bufsize = bufsize
my_turtle.py:            self.buffer = [[None]] * bufsize
my_turtle.py:        self.ptr = -1
my_turtle.py:    def push(self, item):
my_turtle.py:        if self.bufsize > 0:
my_turtle.py:            if not self.cumulate:
my_turtle.py:                self.ptr = (self.ptr + 1) % self.bufsize
my_turtle.py:                self.buffer[self.ptr] = item
my_turtle.py:            else:
my_turtle.py:                self.buffer[self.ptr].append(item)
my_turtle.py:    def pop(self):
my_turtle.py:        if self.bufsize > 0:
my_turtle.py:            item = self.buffer[self.ptr]
my_turtle.py:            if item is None:
my_turtle.py:                return None
my_turtle.py:            else:
my_turtle.py:                self.buffer[self.ptr] = [None]
my_turtle.py:                self.ptr = (self.ptr - 1) % self.bufsize
my_turtle.py:                return (item)
my_turtle.py:    def nr_of_items(self):
my_turtle.py:        return self.bufsize - self.buffer.count([None])
my_turtle.py:    def __repr__(self):
my_turtle.py:        return str(self.buffer) + " " + str(self.ptr)
my_turtle.py:
my_turtle.py:
my_turtle.py:
my_turtle.py:class TurtleScreen(TurtleScreenBase):
my_turtle.py:    """Provides screen oriented methods like setbg etc.
my_turtle.py:
my_turtle.py:    Only relies upon the methods of TurtleScreenBase and NOT
my_turtle.py:    upon components of the underlying graphics toolkit -
my_turtle.py:    which is Tkinter in this case.
my_turtle.py:    """
my_turtle.py:    _RUNNING = True
my_turtle.py:
my_turtle.py:    def __init__(self, cv, mode=_CFG["mode"],
my_turtle.py:                 colormode=_CFG["colormode"], delay=_CFG["delay"]):
my_turtle.py:        self._shapes = {
my_turtle.py:                   "arrow" : Shape("polygon", ((-10,0), (10,0), (0,10))),
my_turtle.py:                  "turtle" : Shape("polygon", ((0,16), (-2,14), (-1,10), (-4,7),
my_turtle.py:                              (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),
my_turtle.py:                              (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),
my_turtle.py:                              (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),
my_turtle.py:                              (2,14))),
my_turtle.py:                  "circle" : Shape("polygon", ((10,0), (9.51,3.09), (8.09,5.88),
my_turtle.py:                              (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),
my_turtle.py:                              (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),
my_turtle.py:                              (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),
my_turtle.py:                              (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),
my_turtle.py:                              (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),
my_turtle.py:                  "square" : Shape("polygon", ((10,-10), (10,10), (-10,10),
my_turtle.py:                              (-10,-10))),
my_turtle.py:                "triangle" : Shape("polygon", ((10,-5.77), (0,11.55),
my_turtle.py:                              (-10,-5.77))),
my_turtle.py:                  "classic": Shape("polygon", ((0,0),(-5,-9),(0,-7),(5,-9))),
my_turtle.py:                   "blank" : Shape("image", self._blankimage())
my_turtle.py:                  }
my_turtle.py:
my_turtle.py:        self._bgpics = {"nopic" : ""}
my_turtle.py:
my_turtle.py:        TurtleScreenBase.__init__(self, cv)
my_turtle.py:        self._mode = mode
my_turtle.py:        self._delayvalue = delay
my_turtle.py:        self._colormode = _CFG["colormode"]
my_turtle.py:        self._keys = []
my_turtle.py:        self.clear()
my_turtle.py:        if sys.platform == 'darwin':
my_turtle.py:            # Force Turtle window to the front on OS X. This is needed because
my_turtle.py:            # the Turtle window will show behind the Terminal window when you
my_turtle.py:            # start the demo from the command line.
my_turtle.py:            rootwindow = cv.winfo_toplevel()
my_turtle.py:            rootwindow.call('wm', 'attributes', '.', '-topmost', '1')
my_turtle.py:            rootwindow.call('wm', 'attributes', '.', '-topmost', '0')
my_turtle.py:
my_turtle.py:    def clear(self):
my_turtle.py:        """Delete all drawings and all turtles from the TurtleScreen.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Reset empty TurtleScreen to its initial state: white background,
my_turtle.py:        no backgroundimage, no eventbindings and tracing on.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.clear()
my_turtle.py:
my_turtle.py:        Note: this method is not available as function.
my_turtle.py:        """
my_turtle.py:        self._delayvalue = _CFG["delay"]
my_turtle.py:        self._colormode = _CFG["colormode"]
my_turtle.py:        self._delete("all")
my_turtle.py:        self._bgpic = self._createimage("")
my_turtle.py:        self._bgpicname = "nopic"
my_turtle.py:        self._tracing = 1
my_turtle.py:        self._updatecounter = 0
my_turtle.py:        self._turtles = []
my_turtle.py:        self.bgcolor("white")
my_turtle.py:        for btn in 1, 2, 3:
my_turtle.py:            self.onclick(None, btn)
my_turtle.py:        self.onkeypress(None)
my_turtle.py:        for key in self._keys[:]:
my_turtle.py:            self.onkey(None, key)
my_turtle.py:            self.onkeypress(None, key)
my_turtle.py:        Turtle._pen = None
my_turtle.py:
my_turtle.py:    def mode(self, mode=None):
my_turtle.py:        """Set turtle-mode ('standard', 'logo' or 'world') and perform reset.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        mode -- on of the strings 'standard', 'logo' or 'world'
my_turtle.py:
my_turtle.py:        Mode 'standard' is compatible with turtle.py.
my_turtle.py:        Mode 'logo' is compatible with most Logo-Turtle-Graphics.
my_turtle.py:        Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in
my_turtle.py:        this mode angles appear distorted if x/y unit-ratio doesn't equal 1.
my_turtle.py:        If mode is not given, return the current mode.
my_turtle.py:
my_turtle.py:             Mode      Initial turtle heading     positive angles
my_turtle.py:         ------------|-------------------------|-------------------
my_turtle.py:          'standard'    to the right (east)       counterclockwise
my_turtle.py:            'logo'        upward    (north)         clockwise
my_turtle.py:
my_turtle.py:        Examples:
my_turtle.py:        >>> mode('logo')   # resets turtle heading to north
my_turtle.py:        >>> mode()
my_turtle.py:        'logo'
my_turtle.py:        """
my_turtle.py:        if mode is None:
my_turtle.py:            return self._mode
my_turtle.py:        mode = mode.casefold()
my_turtle.py:        if mode not in ["standard", "logo", "world"]:
my_turtle.py:            raise TurtleGraphicsError("No turtle-graphics-mode %s" % mode)
my_turtle.py:        self._mode = mode
my_turtle.py:        if mode in ["standard", "logo"]:
my_turtle.py:            self._setscrollregion(-self.canvwidth//2, -self.canvheight//2,
my_turtle.py:                                       self.canvwidth//2, self.canvheight//2)
my_turtle.py:            self.xscale = self.yscale = 1.0
my_turtle.py:        self.reset()
my_turtle.py:
my_turtle.py:    def setworldcoordinates(self, llx, lly, urx, ury):
my_turtle.py:        """Set up a user defined coordinate-system.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        llx -- a number, x-coordinate of lower left corner of canvas
my_turtle.py:        lly -- a number, y-coordinate of lower left corner of canvas
my_turtle.py:        urx -- a number, x-coordinate of upper right corner of canvas
my_turtle.py:        ury -- a number, y-coordinate of upper right corner of canvas
my_turtle.py:
my_turtle.py:        Set up user coodinat-system and switch to mode 'world' if necessary.
my_turtle.py:        This performs a screen.reset. If mode 'world' is already active,
my_turtle.py:        all drawings are redrawn according to the new coordinates.
my_turtle.py:
my_turtle.py:        But ATTENTION: in user-defined coordinatesystems angles may appear
my_turtle.py:        distorted. (see Screen.mode())
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.setworldcoordinates(-10,-0.5,50,1.5)
my_turtle.py:        >>> for _ in range(36):
my_turtle.py:        ...     left(10)
my_turtle.py:        ...     forward(0.5)
my_turtle.py:        """
my_turtle.py:        if self.mode() != "world":
my_turtle.py:            self.mode("world")
my_turtle.py:        xspan = float(urx - llx)
my_turtle.py:        yspan = float(ury - lly)
my_turtle.py:        wx, wy = self._window_size()
my_turtle.py:        self.screensize(wx-20, wy-20)
my_turtle.py:        oldxscale, oldyscale = self.xscale, self.yscale
my_turtle.py:        self.xscale = self.canvwidth / xspan
my_turtle.py:        self.yscale = self.canvheight / yspan
my_turtle.py:        srx1 = llx * self.xscale
my_turtle.py:        sry1 = -ury * self.yscale
my_turtle.py:        srx2 = self.canvwidth + srx1
my_turtle.py:        sry2 = self.canvheight + sry1
my_turtle.py:        self._setscrollregion(srx1, sry1, srx2, sry2)
my_turtle.py:        self._rescale(self.xscale/oldxscale, self.yscale/oldyscale)
my_turtle.py:        self.update()
my_turtle.py:
my_turtle.py:    def register_shape(self, name, shape=None):
my_turtle.py:        """Adds a turtle shape to TurtleScreen's shapelist.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        (1) name is the name of a gif-file and shape is None.
my_turtle.py:            Installs the corresponding image shape.
my_turtle.py:            !! Image-shapes DO NOT rotate when turning the turtle,
my_turtle.py:            !! so they do not display the heading of the turtle!
my_turtle.py:        (2) name is an arbitrary string and shape is a tuple
my_turtle.py:            of pairs of coordinates. Installs the corresponding
my_turtle.py:            polygon shape
my_turtle.py:        (3) name is an arbitrary string and shape is a
my_turtle.py:            (compound) Shape object. Installs the corresponding
my_turtle.py:            compound shape.
my_turtle.py:        To use a shape, you have to issue the command shape(shapename).
my_turtle.py:
my_turtle.py:        call: register_shape("turtle.gif")
my_turtle.py:        --or: register_shape("tri", ((0,0), (10,10), (-10,10)))
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        if shape is None:
my_turtle.py:            # image
my_turtle.py:            if name.casefold().endswith(".gif"):
my_turtle.py:                shape = Shape("image", self._image(name))
my_turtle.py:            else:
my_turtle.py:                raise TurtleGraphicsError("Bad arguments for register_shape.\n"
my_turtle.py:                                          + "Use  help(register_shape)" )
my_turtle.py:        elif isinstance(shape, tuple):
my_turtle.py:            shape = Shape("polygon", shape)
my_turtle.py:        ## else shape assumed to be Shape-instance
my_turtle.py:        self._shapes[name] = shape
my_turtle.py:
my_turtle.py:    def _colorstr(self, color):
my_turtle.py:        """Return color string corresponding to args.
my_turtle.py:
my_turtle.py:        Argument may be a string or a tuple of three
my_turtle.py:        numbers corresponding to actual colormode,
my_turtle.py:        i.e. in the range 0<=n<=colormode.
my_turtle.py:
my_turtle.py:        If the argument doesn't represent a color,
my_turtle.py:        an error is raised.
my_turtle.py:        """
my_turtle.py:        if len(color) == 1:
my_turtle.py:            color = color[0]
my_turtle.py:        if isinstance(color, str):
my_turtle.py:            if self._iscolorstring(color) or color == "":
my_turtle.py:                return color
my_turtle.py:            else:
my_turtle.py:                raise TurtleGraphicsError("bad color string: %s" % str(color))
my_turtle.py:        try:
my_turtle.py:            r, g, b = color
my_turtle.py:        except:
my_turtle.py:            raise TurtleGraphicsError("bad color arguments: %s" % str(color))
my_turtle.py:        if self._colormode == 1.0:
my_turtle.py:            r, g, b = [round(255.0*x) for x in (r, g, b)]
my_turtle.py:        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
my_turtle.py:            raise TurtleGraphicsError("bad color sequence: %s" % str(color))
my_turtle.py:        return "#%02x%02x%02x" % (r, g, b)
my_turtle.py:
my_turtle.py:    def _color(self, cstr):
my_turtle.py:        if not cstr.startswith("#"):
my_turtle.py:            return cstr
my_turtle.py:        if len(cstr) == 7:
my_turtle.py:            cl = [int(cstr[i:i+2], 16) for i in (1, 3, 5)]
my_turtle.py:        elif len(cstr) == 4:
my_turtle.py:            cl = [16*int(cstr[h], 16) for h in cstr[1:]]
my_turtle.py:        else:
my_turtle.py:            raise TurtleGraphicsError("bad colorstring: %s" % cstr)
my_turtle.py:        return tuple([c * self._colormode/255 for c in cl])
my_turtle.py:
my_turtle.py:    def colormode(self, cmode=None):
my_turtle.py:        """Return the colormode or set it to 1.0 or 255.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        cmode -- one of the values 1.0 or 255
my_turtle.py:
my_turtle.py:        r, g, b values of colortriples have to be in range 0..cmode.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.colormode()
my_turtle.py:        1.0
my_turtle.py:        >>> screen.colormode(255)
my_turtle.py:        >>> pencolor(240,160,80)
my_turtle.py:        """
my_turtle.py:        if cmode is None:
my_turtle.py:            return self._colormode
my_turtle.py:        if cmode == 1.0:
my_turtle.py:            self._colormode = float(cmode)
my_turtle.py:        elif cmode == 255:
my_turtle.py:            self._colormode = int(cmode)
my_turtle.py:
my_turtle.py:    def reset(self):
my_turtle.py:        """Reset all Turtles on the Screen to their initial state.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.reset()
my_turtle.py:        """
my_turtle.py:        for turtle in self._turtles:
my_turtle.py:            turtle._setmode(self._mode)
my_turtle.py:            turtle.reset()
my_turtle.py:
my_turtle.py:    def turtles(self):
my_turtle.py:        """Return the list of turtles on the screen.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.turtles()
my_turtle.py:        [<turtle.Turtle object at 0x00E11FB0>]
my_turtle.py:        """
my_turtle.py:        return self._turtles
my_turtle.py:
my_turtle.py:    def bgcolor(self, *args):
my_turtle.py:        """Set or return backgroundcolor of the TurtleScreen.
my_turtle.py:
my_turtle.py:        Arguments (if given): a color string or three numbers
my_turtle.py:        in the range 0..colormode or a 3-tuple of such numbers.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.bgcolor("orange")
my_turtle.py:        >>> screen.bgcolor()
my_turtle.py:        'orange'
my_turtle.py:        >>> screen.bgcolor(0.5,0,0.5)
my_turtle.py:        >>> screen.bgcolor()
my_turtle.py:        '#800080'
my_turtle.py:        """
my_turtle.py:        if args:
my_turtle.py:            color = self._colorstr(args)
my_turtle.py:        else:
my_turtle.py:            color = None
my_turtle.py:        color = self._bgcolor(color)
my_turtle.py:        if color is not None:
my_turtle.py:            color = self._color(color)
my_turtle.py:        return color
my_turtle.py:
my_turtle.py:    def tracer(self, n=None, delay=None):
my_turtle.py:        """Turns turtle animation on/off and set delay for update drawings.
my_turtle.py:
my_turtle.py:        Optional arguments:
my_turtle.py:        n -- nonnegative  integer
my_turtle.py:        delay -- nonnegative  integer
my_turtle.py:
my_turtle.py:        If n is given, only each n-th regular screen update is really performed.
my_turtle.py:        (Can be used to accelerate the drawing of complex graphics.)
my_turtle.py:        Second arguments sets delay value (see RawTurtle.delay())
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.tracer(8, 25)
my_turtle.py:        >>> dist = 2
my_turtle.py:        >>> for i in range(200):
my_turtle.py:        ...     fd(dist)
my_turtle.py:        ...     rt(90)
my_turtle.py:        ...     dist += 2
my_turtle.py:        """
my_turtle.py:        if n is None:
my_turtle.py:            return self._tracing
my_turtle.py:        self._tracing = int(n)
my_turtle.py:        self._updatecounter = 0
my_turtle.py:        if delay is not None:
my_turtle.py:            self._delayvalue = int(delay)
my_turtle.py:        if self._tracing:
my_turtle.py:            self.update()
my_turtle.py:
my_turtle.py:    def delay(self, delay=None):
my_turtle.py:        """ Return or set the drawing delay in milliseconds.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        delay -- positive integer
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.delay(15)
my_turtle.py:        >>> screen.delay()
my_turtle.py:        15
my_turtle.py:        """
my_turtle.py:        if delay is None:
my_turtle.py:            return self._delayvalue
my_turtle.py:        self._delayvalue = int(delay)
my_turtle.py:
my_turtle.py:    def _incrementudc(self):
my_turtle.py:        """Increment update counter."""
my_turtle.py:        if not TurtleScreen._RUNNING:
my_turtle.py:            TurtleScreen._RUNNING = True
my_turtle.py:            raise Terminator
my_turtle.py:        if self._tracing > 0:
my_turtle.py:            self._updatecounter += 1
my_turtle.py:            self._updatecounter %= self._tracing
my_turtle.py:
my_turtle.py:    def update(self):
my_turtle.py:        """Perform a TurtleScreen update.
my_turtle.py:        """
my_turtle.py:        tracing = self._tracing
my_turtle.py:        self._tracing = True
my_turtle.py:        for t in self.turtles():
my_turtle.py:            t._update_data()
my_turtle.py:            t._drawturtle()
my_turtle.py:        self._tracing = tracing
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def window_width(self):
my_turtle.py:        """ Return the width of the turtle window.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.window_width()
my_turtle.py:        640
my_turtle.py:        """
my_turtle.py:        return self._window_size()[0]
my_turtle.py:
my_turtle.py:    def window_height(self):
my_turtle.py:        """ Return the height of the turtle window.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.window_height()
my_turtle.py:        480
my_turtle.py:        """
my_turtle.py:        return self._window_size()[1]
my_turtle.py:
my_turtle.py:    def getcanvas(self):
my_turtle.py:        """Return the Canvas of this TurtleScreen.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Screen instance named screen):
my_turtle.py:        >>> cv = screen.getcanvas()
my_turtle.py:        >>> cv
my_turtle.py:        <turtle.ScrolledCanvas instance at 0x010742D8>
my_turtle.py:        """
my_turtle.py:        return self.cv
my_turtle.py:
my_turtle.py:    def getshapes(self):
my_turtle.py:        """Return a list of names of all currently available turtle shapes.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.getshapes()
my_turtle.py:        ['arrow', 'blank', 'circle', ... , 'turtle']
my_turtle.py:        """
my_turtle.py:        return sorted(self._shapes.keys())
my_turtle.py:
my_turtle.py:    def onclick(self, fun, btn=1, add=None, args=None):
my_turtle.py:        """Bind fun to mouse-click event on canvas.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with two arguments, the coordinates of the
my_turtle.py:               clicked point on the canvas.
my_turtle.py:        num -- the number of the mouse-button, defaults to 1
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen)
my_turtle.py:
my_turtle.py:        >>> screen.onclick(goto)
my_turtle.py:        >>> # Subsequently clicking into the TurtleScreen will
my_turtle.py:        >>> # make the turtle move to the clicked point.
my_turtle.py:        >>> screen.onclick(None)
my_turtle.py:        """
my_turtle.py:        self._onscreenclick(fun, btn, add, args)
my_turtle.py:
my_turtle.py:    def onkey(self, fun, key):
my_turtle.py:        """Bind fun to key-release event of key.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with no arguments
my_turtle.py:        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")
my_turtle.py:
my_turtle.py:        In order to be able to register key-events, TurtleScreen
my_turtle.py:        must have focus. (See method listen.)
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:
my_turtle.py:        >>> def f():
my_turtle.py:        ...     fd(50)
my_turtle.py:        ...     lt(60)
my_turtle.py:        ...
my_turtle.py:        >>> screen.onkey(f, "Up")
my_turtle.py:        >>> screen.listen()
my_turtle.py:
my_turtle.py:        Subsequently the turtle can be moved by repeatedly pressing
my_turtle.py:        the up-arrow key, consequently drawing a hexagon
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            if key in self._keys:
my_turtle.py:                self._keys.remove(key)
my_turtle.py:        elif key not in self._keys:
my_turtle.py:            self._keys.append(key)
my_turtle.py:        self._onkeyrelease(fun, key)
my_turtle.py:
my_turtle.py:    def onkeypress(self, fun, key=None):
my_turtle.py:        """Bind fun to key-press event of key if key is given,
my_turtle.py:        or to any key-press-event if no key is given.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with no arguments
my_turtle.py:        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")
my_turtle.py:
my_turtle.py:        In order to be able to register key-events, TurtleScreen
my_turtle.py:        must have focus. (See method listen.)
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen
my_turtle.py:        and a Turtle instance named turtle):
my_turtle.py:
my_turtle.py:        >>> def f():
my_turtle.py:        ...     fd(50)
my_turtle.py:        ...     lt(60)
my_turtle.py:        ...
my_turtle.py:        >>> screen.onkeypress(f, "Up")
my_turtle.py:        >>> screen.listen()
my_turtle.py:
my_turtle.py:        Subsequently the turtle can be moved by repeatedly pressing
my_turtle.py:        the up-arrow key, or by keeping pressed the up-arrow key.
my_turtle.py:        consequently drawing a hexagon.
my_turtle.py:        """
my_turtle.py:        if fun is None:
my_turtle.py:            if key in self._keys:
my_turtle.py:                self._keys.remove(key)
my_turtle.py:        elif key is not None and key not in self._keys:
my_turtle.py:            self._keys.append(key)
my_turtle.py:        self._onkeypress(fun, key)
my_turtle.py:
my_turtle.py:    def listen(self, xdummy=None, ydummy=None):
my_turtle.py:        """Set focus on TurtleScreen (in order to collect key-events)
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:        Dummy arguments are provided in order
my_turtle.py:        to be able to pass listen to the onclick method.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.listen()
my_turtle.py:        """
my_turtle.py:        self._listen()
my_turtle.py:
my_turtle.py:    def ontimer(self, fun, t=0):
my_turtle.py:        """Install a timer, which calls fun after t milliseconds.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with no arguments.
my_turtle.py:        t -- a number >= 0
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:
my_turtle.py:        >>> running = True
my_turtle.py:        >>> def f():
my_turtle.py:        ...     if running:
my_turtle.py:        ...             fd(50)
my_turtle.py:        ...             lt(60)
my_turtle.py:        ...             screen.ontimer(f, 250)
my_turtle.py:        ...
my_turtle.py:        >>> f()   # makes the turtle marching around
my_turtle.py:        >>> running = False
my_turtle.py:        """
my_turtle.py:        self._ontimer(fun, t)
my_turtle.py:
my_turtle.py:    def bgpic(self, picname=None):
my_turtle.py:        """Set background image or return name of current backgroundimage.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        picname -- a string, name of a gif-file or "nopic".
my_turtle.py:
my_turtle.py:        If picname is a filename, set the corresponding image as background.
my_turtle.py:        If picname is "nopic", delete backgroundimage, if present.
my_turtle.py:        If picname is None, return the filename of the current backgroundimage.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.bgpic()
my_turtle.py:        'nopic'
my_turtle.py:        >>> screen.bgpic("landscape.gif")
my_turtle.py:        >>> screen.bgpic()
my_turtle.py:        'landscape.gif'
my_turtle.py:        """
my_turtle.py:        if picname is None:
my_turtle.py:            return self._bgpicname
my_turtle.py:        if picname not in self._bgpics:
my_turtle.py:            self._bgpics[picname] = self._image(picname)
my_turtle.py:        self._setbgpic(self._bgpic, self._bgpics[picname])
my_turtle.py:        self._bgpicname = picname
my_turtle.py:
my_turtle.py:    def screensize(self, canvwidth=None, canvheight=None, bg=None):
my_turtle.py:        """Resize the canvas the turtles are drawing on.
my_turtle.py:
my_turtle.py:        Optional arguments:
my_turtle.py:        canvwidth -- positive integer, new width of canvas in pixels
my_turtle.py:        canvheight --  positive integer, new height of canvas in pixels
my_turtle.py:        bg -- colorstring or color-tuple, new backgroundcolor
my_turtle.py:        If no arguments are given, return current (canvaswidth, canvasheight)
my_turtle.py:
my_turtle.py:        Do not alter the drawing window. To observe hidden parts of
my_turtle.py:        the canvas use the scrollbars. (Can make visible those parts
my_turtle.py:        of a drawing, which were outside the canvas before!)
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.screensize(2000,1500)
my_turtle.py:        >>> # e.g. to search for an erroneously escaped turtle ;-)
my_turtle.py:        """
my_turtle.py:        return self._resize(canvwidth, canvheight, bg)
my_turtle.py:
my_turtle.py:    onscreenclick = onclick
my_turtle.py:    resetscreen = reset
my_turtle.py:    clearscreen = clear
my_turtle.py:    addshape = register_shape
my_turtle.py:    onkeyrelease = onkey
my_turtle.py:
my_turtle.py:class TNavigator(object):
my_turtle.py:    """Navigation part of the RawTurtle.
my_turtle.py:    Implements methods for turtle movement.
my_turtle.py:    """
my_turtle.py:    START_ORIENTATION = {
my_turtle.py:        "standard": Vec2D(1.0, 0.0),
my_turtle.py:        "world"   : Vec2D(1.0, 0.0),
my_turtle.py:        "logo"    : Vec2D(0.0, 1.0)  }
my_turtle.py:    DEFAULT_MODE = "standard"
my_turtle.py:    DEFAULT_ANGLEOFFSET = 0
my_turtle.py:    DEFAULT_ANGLEORIENT = 1
my_turtle.py:
my_turtle.py:    def __init__(self, mode=DEFAULT_MODE):
my_turtle.py:        self._angleOffset = self.DEFAULT_ANGLEOFFSET
my_turtle.py:        self._angleOrient = self.DEFAULT_ANGLEORIENT
my_turtle.py:        self._mode = mode
my_turtle.py:        self.undobuffer = None
my_turtle.py:        self.degrees()
my_turtle.py:        self._mode = None
my_turtle.py:        self._setmode(mode)
my_turtle.py:        TNavigator.reset(self)
my_turtle.py:
my_turtle.py:    def reset(self):
my_turtle.py:        """reset turtle to its initial values
my_turtle.py:
my_turtle.py:        Will be overwritten by parent class
my_turtle.py:        """
my_turtle.py:        self._position = Vec2D(0.0, 0.0)
my_turtle.py:        self._orient =  TNavigator.START_ORIENTATION[self._mode]
my_turtle.py:
my_turtle.py:    def _setmode(self, mode=None):
my_turtle.py:        """Set turtle-mode to 'standard', 'world' or 'logo'.
my_turtle.py:        """
my_turtle.py:        if mode is None:
my_turtle.py:            return self._mode
my_turtle.py:        if mode not in ["standard", "logo", "world"]:
my_turtle.py:            return
my_turtle.py:        self._mode = mode
my_turtle.py:        if mode in ["standard", "world"]:
my_turtle.py:            self._angleOffset = 0
my_turtle.py:            self._angleOrient = 1
my_turtle.py:        else: # mode == "logo":
my_turtle.py:            self._angleOffset = self._fullcircle/4.
my_turtle.py:            self._angleOrient = -1
my_turtle.py:
my_turtle.py:    def _setDegreesPerAU(self, fullcircle):
my_turtle.py:        """Helper function for degrees() and radians()"""
my_turtle.py:        self._fullcircle = fullcircle
my_turtle.py:        self._degreesPerAU = 360/fullcircle
my_turtle.py:        if self._mode == "standard":
my_turtle.py:            self._angleOffset = 0
my_turtle.py:        else:
my_turtle.py:            self._angleOffset = fullcircle/4.
my_turtle.py:
my_turtle.py:    def degrees(self, fullcircle=360.0):
my_turtle.py:        """ Set angle measurement units to degrees.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        fullcircle -  a number
my_turtle.py:
my_turtle.py:        Set angle measurement units, i. e. set number
my_turtle.py:        of 'degrees' for a full circle. Dafault value is
my_turtle.py:        360 degrees.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.left(90)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        90
my_turtle.py:
my_turtle.py:        Change angle measurement unit to grad (also known as gon,
my_turtle.py:        grade, or gradian and equals 1/100-th of the right angle.)
my_turtle.py:        >>> turtle.degrees(400.0)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        100
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        self._setDegreesPerAU(fullcircle)
my_turtle.py:
my_turtle.py:    def radians(self):
my_turtle.py:        """ Set the angle measurement units to radians.
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        90
my_turtle.py:        >>> turtle.radians()
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        1.5707963267948966
my_turtle.py:        """
my_turtle.py:        self._setDegreesPerAU(2*math.pi)
my_turtle.py:
my_turtle.py:    def _go(self, distance):
my_turtle.py:        """move turtle forward by specified distance"""
my_turtle.py:        ende = self._position + self._orient * distance
my_turtle.py:        self._goto(ende)
my_turtle.py:
my_turtle.py:    def _rotate(self, angle):
my_turtle.py:        """Turn turtle counterclockwise by specified angle if angle > 0."""
my_turtle.py:        angle *= self._degreesPerAU
my_turtle.py:        self._orient = self._orient.rotate(angle)
my_turtle.py:
my_turtle.py:    def _goto(self, end):
my_turtle.py:        """move turtle to position end."""
my_turtle.py:        self._position = end
my_turtle.py:
my_turtle.py:    def forward(self, distance):
my_turtle.py:        """Move the turtle forward by the specified distance.
my_turtle.py:
my_turtle.py:        Aliases: forward | fd
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        distance -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Move the turtle forward by the specified distance, in the direction
my_turtle.py:        the turtle is headed.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00, 0.00)
my_turtle.py:        >>> turtle.forward(25)
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (25.00,0.00)
my_turtle.py:        >>> turtle.forward(-75)
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (-50.00,0.00)
my_turtle.py:        """
my_turtle.py:        self._go(distance)
my_turtle.py:
my_turtle.py:    def back(self, distance):
my_turtle.py:        """Move the turtle backward by distance.
my_turtle.py:
my_turtle.py:        Aliases: back | backward | bk
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        distance -- a number
my_turtle.py:
my_turtle.py:        Move the turtle backward by distance ,opposite to the direction the
my_turtle.py:        turtle is headed. Do not change the turtle's heading.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00, 0.00)
my_turtle.py:        >>> turtle.backward(30)
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (-30.00, 0.00)
my_turtle.py:        """
my_turtle.py:        self._go(-distance)
my_turtle.py:
my_turtle.py:    def right(self, angle):
my_turtle.py:        """Turn turtle right by angle units.
my_turtle.py:
my_turtle.py:        Aliases: right | rt
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        angle -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Turn turtle right by angle units. (Units are by default degrees,
my_turtle.py:        but can be set via the degrees() and radians() functions.)
my_turtle.py:        Angle orientation depends on mode. (See this.)
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        22.0
my_turtle.py:        >>> turtle.right(45)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        337.0
my_turtle.py:        """
my_turtle.py:        self._rotate(-angle)
my_turtle.py:
my_turtle.py:    def left(self, angle):
my_turtle.py:        """Turn turtle left by angle units.
my_turtle.py:
my_turtle.py:        Aliases: left | lt
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        angle -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Turn turtle left by angle units. (Units are by default degrees,
my_turtle.py:        but can be set via the degrees() and radians() functions.)
my_turtle.py:        Angle orientation depends on mode. (See this.)
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        22.0
my_turtle.py:        >>> turtle.left(45)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        67.0
my_turtle.py:        """
my_turtle.py:        self._rotate(angle)
my_turtle.py:
my_turtle.py:    def pos(self):
my_turtle.py:        """Return the turtle's current location (x,y), as a Vec2D-vector.
my_turtle.py:
my_turtle.py:        Aliases: pos | position
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (0.00, 240.00)
my_turtle.py:        """
my_turtle.py:        return self._position
my_turtle.py:
my_turtle.py:    def xcor(self):
my_turtle.py:        """ Return the turtle's x coordinate.
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> reset()
my_turtle.py:        >>> turtle.left(60)
my_turtle.py:        >>> turtle.forward(100)
my_turtle.py:        >>> print turtle.xcor()
my_turtle.py:        50.0
my_turtle.py:        """
my_turtle.py:        return self._position[0]
my_turtle.py:
my_turtle.py:    def ycor(self):
my_turtle.py:        """ Return the turtle's y coordinate
my_turtle.py:        ---
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> reset()
my_turtle.py:        >>> turtle.left(60)
my_turtle.py:        >>> turtle.forward(100)
my_turtle.py:        >>> print turtle.ycor()
my_turtle.py:        86.6025403784
my_turtle.py:        """
my_turtle.py:        return self._position[1]
my_turtle.py:
my_turtle.py:
my_turtle.py:    def goto(self, x, y=None):
my_turtle.py:        """Move turtle to an absolute position.
my_turtle.py:
my_turtle.py:        Aliases: setpos | setposition | goto:
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        x -- a number      or     a pair/vector of numbers
my_turtle.py:        y -- a number             None
my_turtle.py:
my_turtle.py:        call: goto(x, y)         # two coordinates
my_turtle.py:        --or: goto((x, y))       # a pair (tuple) of coordinates
my_turtle.py:        --or: goto(vec)          # e.g. as returned by pos()
my_turtle.py:
my_turtle.py:        Move turtle to an absolute position. If the pen is down,
my_turtle.py:        a line will be drawn. The turtle's orientation does not change.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> tp = turtle.pos()
my_turtle.py:        >>> tp
my_turtle.py:        (0.00, 0.00)
my_turtle.py:        >>> turtle.setpos(60,30)
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (60.00,30.00)
my_turtle.py:        >>> turtle.setpos((20,80))
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (20.00,80.00)
my_turtle.py:        >>> turtle.setpos(tp)
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (0.00,0.00)
my_turtle.py:        """
my_turtle.py:        if y is None:
my_turtle.py:            self._goto(Vec2D(*x))
my_turtle.py:        else:
my_turtle.py:            self._goto(Vec2D(x, y))
my_turtle.py:
my_turtle.py:    def home(self):
my_turtle.py:        """Move turtle to the origin - coordinates (0,0).
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Move turtle to the origin - coordinates (0,0) and set its
my_turtle.py:        heading to its start-orientation (which depends on mode).
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.home()
my_turtle.py:        """
my_turtle.py:        self.goto(0, 0)
my_turtle.py:        self.setheading(0)
my_turtle.py:
my_turtle.py:    def setx(self, x):
my_turtle.py:        """Set the turtle's first coordinate to x
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        x -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Set the turtle's first coordinate to x, leave second coordinate
my_turtle.py:        unchanged.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00, 240.00)
my_turtle.py:        >>> turtle.setx(10)
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (10.00, 240.00)
my_turtle.py:        """
my_turtle.py:        self._goto(Vec2D(x, self._position[1]))
my_turtle.py:
my_turtle.py:    def sety(self, y):
my_turtle.py:        """Set the turtle's second coordinate to y
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        y -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Set the turtle's first coordinate to x, second coordinate remains
my_turtle.py:        unchanged.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00, 40.00)
my_turtle.py:        >>> turtle.sety(-10)
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00, -10.00)
my_turtle.py:        """
my_turtle.py:        self._goto(Vec2D(self._position[0], y))
my_turtle.py:
my_turtle.py:    def distance(self, x, y=None):
my_turtle.py:        """Return the distance from the turtle to (x,y) in turtle step units.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        x -- a number   or  a pair/vector of numbers   or   a turtle instance
my_turtle.py:        y -- a number       None                            None
my_turtle.py:
my_turtle.py:        call: distance(x, y)         # two coordinates
my_turtle.py:        --or: distance((x, y))       # a pair (tuple) of coordinates
my_turtle.py:        --or: distance(vec)          # e.g. as returned by pos()
my_turtle.py:        --or: distance(mypen)        # where mypen is another turtle
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (0.00, 0.00)
my_turtle.py:        >>> turtle.distance(30,40)
my_turtle.py:        50.0
my_turtle.py:        >>> pen = Turtle()
my_turtle.py:        >>> pen.forward(77)
my_turtle.py:        >>> turtle.distance(pen)
my_turtle.py:        77.0
my_turtle.py:        """
my_turtle.py:        if y is not None:
my_turtle.py:            pos = Vec2D(x, y)
my_turtle.py:        if isinstance(x, Vec2D):
my_turtle.py:            pos = x
my_turtle.py:        elif isinstance(x, tuple):
my_turtle.py:            pos = Vec2D(*x)
my_turtle.py:        elif isinstance(x, TNavigator):
my_turtle.py:            pos = x._position
my_turtle.py:        return abs(pos - self._position)
my_turtle.py:
my_turtle.py:    def towards(self, x, y=None):
my_turtle.py:        """Return the angle of the line from the turtle's position to (x, y).
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        x -- a number   or  a pair/vector of numbers   or   a turtle instance
my_turtle.py:        y -- a number       None                            None
my_turtle.py:
my_turtle.py:        call: distance(x, y)         # two coordinates
my_turtle.py:        --or: distance((x, y))       # a pair (tuple) of coordinates
my_turtle.py:        --or: distance(vec)          # e.g. as returned by pos()
my_turtle.py:        --or: distance(mypen)        # where mypen is another turtle
my_turtle.py:
my_turtle.py:        Return the angle, between the line from turtle-position to position
my_turtle.py:        specified by x, y and the turtle's start orientation. (Depends on
my_turtle.py:        modes - "standard" or "logo")
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pos()
my_turtle.py:        (10.00, 10.00)
my_turtle.py:        >>> turtle.towards(0,0)
my_turtle.py:        225.0
my_turtle.py:        """
my_turtle.py:        if y is not None:
my_turtle.py:            pos = Vec2D(x, y)
my_turtle.py:        if isinstance(x, Vec2D):
my_turtle.py:            pos = x
my_turtle.py:        elif isinstance(x, tuple):
my_turtle.py:            pos = Vec2D(*x)
my_turtle.py:        elif isinstance(x, TNavigator):
my_turtle.py:            pos = x._position
my_turtle.py:        x, y = pos - self._position
my_turtle.py:        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
my_turtle.py:        result /= self._degreesPerAU
my_turtle.py:        return (self._angleOffset + self._angleOrient*result) % self._fullcircle
my_turtle.py:
my_turtle.py:    def heading(self):
my_turtle.py:        """ Return the turtle's current heading.
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.left(67)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        67.0
my_turtle.py:        """
my_turtle.py:        x, y = self._orient
my_turtle.py:        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
my_turtle.py:        result /= self._degreesPerAU
my_turtle.py:        return (self._angleOffset + self._angleOrient*result) % self._fullcircle
my_turtle.py:
my_turtle.py:    def setheading(self, to_angle):
my_turtle.py:        """Set the orientation of the turtle to to_angle.
my_turtle.py:
my_turtle.py:        Aliases:  setheading | seth
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        to_angle -- a number (integer or float)
my_turtle.py:
my_turtle.py:        Set the orientation of the turtle to to_angle.
my_turtle.py:        Here are some common directions in degrees:
my_turtle.py:
my_turtle.py:         standard - mode:          logo-mode:
my_turtle.py:        -------------------|--------------------
my_turtle.py:           0 - east                0 - north
my_turtle.py:          90 - north              90 - east
my_turtle.py:         180 - west              180 - south
my_turtle.py:         270 - south             270 - west
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.setheading(90)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        90
my_turtle.py:        """
my_turtle.py:        angle = (to_angle - self.heading())*self._angleOrient
my_turtle.py:        full = self._fullcircle
my_turtle.py:        angle = (angle+full/2.)%full - full/2.
my_turtle.py:        self._rotate(angle)
my_turtle.py:
my_turtle.py:    def circle(self, radius, extent = None, steps = None):
my_turtle.py:        """ Draw a circle with given radius.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        radius -- a number
my_turtle.py:        extent (optional) -- a number
my_turtle.py:        steps (optional) -- an integer
my_turtle.py:
my_turtle.py:        Draw a circle with given radius. The center is radius units left
my_turtle.py:        of the turtle; extent - an angle - determines which part of the
my_turtle.py:        circle is drawn. If extent is not given, draw the entire circle.
my_turtle.py:        If extent is not a full circle, one endpoint of the arc is the
my_turtle.py:        current pen position. Draw the arc in counterclockwise direction
my_turtle.py:        if radius is positive, otherwise in clockwise direction. Finally
my_turtle.py:        the direction of the turtle is changed by the amount of extent.
my_turtle.py:
my_turtle.py:        As the circle is approximated by an inscribed regular polygon,
my_turtle.py:        steps determines the number of steps to use. If not given,
my_turtle.py:        it will be calculated automatically. Maybe used to draw regular
my_turtle.py:        polygons.
my_turtle.py:
my_turtle.py:        call: circle(radius)                  # full circle
my_turtle.py:        --or: circle(radius, extent)          # arc
my_turtle.py:        --or: circle(radius, extent, steps)
my_turtle.py:        --or: circle(radius, steps=6)         # 6-sided polygon
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.circle(50)
my_turtle.py:        >>> turtle.circle(120, 180)  # semicircle
my_turtle.py:        """
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(["seq"])
my_turtle.py:            self.undobuffer.cumulate = True
my_turtle.py:        speed = self.speed()
my_turtle.py:        if extent is None:
my_turtle.py:            extent = self._fullcircle
my_turtle.py:        if steps is None:
my_turtle.py:            frac = abs(extent)/self._fullcircle
my_turtle.py:            steps = 1+int(min(11+abs(radius)/6.0, 59.0)*frac)
my_turtle.py:        w = 1.0 * extent / steps
my_turtle.py:        w2 = 0.5 * w
my_turtle.py:        l = 2.0 * radius * math.sin(w2*math.pi/180.0*self._degreesPerAU)
my_turtle.py:        if radius < 0:
my_turtle.py:            l, w, w2 = -l, -w, -w2
my_turtle.py:        tr = self._tracer()
my_turtle.py:        dl = self._delay()
my_turtle.py:        if speed == 0:
my_turtle.py:            self._tracer(0, 0)
my_turtle.py:        else:
my_turtle.py:            self.speed(0)
my_turtle.py:        self._rotate(w2)
my_turtle.py:        for i in range(steps):
my_turtle.py:            self.speed(speed)
my_turtle.py:            self._go(l)
my_turtle.py:            self.speed(0)
my_turtle.py:            self._rotate(w)
my_turtle.py:        self._rotate(-w2)
my_turtle.py:        if speed == 0:
my_turtle.py:            self._tracer(tr, dl)
my_turtle.py:        self.speed(speed)
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.cumulate = False
my_turtle.py:
my_turtle.py:## three dummy methods to be implemented by child class:
my_turtle.py:
my_turtle.py:    def speed(self, s=0):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:    def _tracer(self, a=None, b=None):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:    def _delay(self, n=None):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:
my_turtle.py:    fd = forward
my_turtle.py:    bk = back
my_turtle.py:    backward = back
my_turtle.py:    rt = right
my_turtle.py:    lt = left
my_turtle.py:    position = pos
my_turtle.py:    setpos = goto
my_turtle.py:    setposition = goto
my_turtle.py:    seth = setheading
my_turtle.py:
my_turtle.py:
my_turtle.py:class TPen(object):
my_turtle.py:    """Drawing part of the RawTurtle.
my_turtle.py:    Implements drawing properties.
my_turtle.py:    """
my_turtle.py:    def __init__(self, resizemode=_CFG["resizemode"]):
my_turtle.py:        self._resizemode = resizemode # or "user" or "noresize"
my_turtle.py:        self.undobuffer = None
my_turtle.py:        TPen._reset(self)
my_turtle.py:
my_turtle.py:    def _reset(self, pencolor=_CFG["pencolor"],
my_turtle.py:                     fillcolor=_CFG["fillcolor"]):
my_turtle.py:        self._pensize = 1
my_turtle.py:        self._shown = True
my_turtle.py:        self._pencolor = pencolor
my_turtle.py:        self._fillcolor = fillcolor
my_turtle.py:        self._drawing = True
my_turtle.py:        self._speed = 3
my_turtle.py:        self._stretchfactor = (1., 1.)
my_turtle.py:        self._shearfactor = 0.
my_turtle.py:        self._tilt = 0.
my_turtle.py:        self._shapetrafo = (1., 0., 0., 1.)
my_turtle.py:        self._outlinewidth = 1
my_turtle.py:
my_turtle.py:    def resizemode(self, rmode=None):
my_turtle.py:        """Set resizemode to one of the values: "auto", "user", "noresize".
my_turtle.py:
my_turtle.py:        (Optional) Argument:
my_turtle.py:        rmode -- one of the strings "auto", "user", "noresize"
my_turtle.py:
my_turtle.py:        Different resizemodes have the following effects:
my_turtle.py:          - "auto" adapts the appearance of the turtle
my_turtle.py:                   corresponding to the value of pensize.
my_turtle.py:          - "user" adapts the appearance of the turtle according to the
my_turtle.py:                   values of stretchfactor and outlinewidth (outline),
my_turtle.py:                   which are set by shapesize()
my_turtle.py:          - "noresize" no adaption of the turtle's appearance takes place.
my_turtle.py:        If no argument is given, return current resizemode.
my_turtle.py:        resizemode("user") is called by a call of shapesize with arguments.
my_turtle.py:
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.resizemode("noresize")
my_turtle.py:        >>> turtle.resizemode()
my_turtle.py:        'noresize'
my_turtle.py:        """
my_turtle.py:        if rmode is None:
my_turtle.py:            return self._resizemode
my_turtle.py:        rmode = rmode.casefold()
my_turtle.py:        if rmode in ["auto", "user", "noresize"]:
my_turtle.py:            self.pen(resizemode=rmode)
my_turtle.py:
my_turtle.py:    def pensize(self, width=None):
my_turtle.py:        """Set or return the line thickness.
my_turtle.py:
my_turtle.py:        Aliases:  pensize | width
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        width -- positive number
my_turtle.py:
my_turtle.py:        Set the line thickness to width or return it. If resizemode is set
my_turtle.py:        to "auto" and turtleshape is a polygon, that polygon is drawn with
my_turtle.py:        the same line thickness. If no argument is given, current pensize
my_turtle.py:        is returned.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pensize()
my_turtle.py:        1
my_turtle.py:        >>> turtle.pensize(10)   # from here on lines of width 10 are drawn
my_turtle.py:        """
my_turtle.py:        if width is None:
my_turtle.py:            return self._pensize
my_turtle.py:        self.pen(pensize=width)
my_turtle.py:
my_turtle.py:
my_turtle.py:    def penup(self):
my_turtle.py:        """Pull the pen up -- no drawing when moving.
my_turtle.py:
my_turtle.py:        Aliases: penup | pu | up
my_turtle.py:
my_turtle.py:        No argument
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.penup()
my_turtle.py:        """
my_turtle.py:        if not self._drawing:
my_turtle.py:            return
my_turtle.py:        self.pen(pendown=False)
my_turtle.py:
my_turtle.py:    def pendown(self):
my_turtle.py:        """Pull the pen down -- drawing when moving.
my_turtle.py:
my_turtle.py:        Aliases: pendown | pd | down
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pendown()
my_turtle.py:        """
my_turtle.py:        if self._drawing:
my_turtle.py:            return
my_turtle.py:        self.pen(pendown=True)
my_turtle.py:
my_turtle.py:    def isdown(self):
my_turtle.py:        """Return True if pen is down, False if it's up.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.penup()
my_turtle.py:        >>> turtle.isdown()
my_turtle.py:        False
my_turtle.py:        >>> turtle.pendown()
my_turtle.py:        >>> turtle.isdown()
my_turtle.py:        True
my_turtle.py:        """
my_turtle.py:        return self._drawing
my_turtle.py:
my_turtle.py:    def speed(self, speed=None):
my_turtle.py:        """ Return or set the turtle's speed.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        speed -- an integer in the range 0..10 or a speedstring (see below)
my_turtle.py:
my_turtle.py:        Set the turtle's speed to an integer value in the range 0 .. 10.
my_turtle.py:        If no argument is given: return current speed.
my_turtle.py:
my_turtle.py:        If input is a number greater than 10 or smaller than 0.5,
my_turtle.py:        speed is set to 0.
my_turtle.py:        Speedstrings  are mapped to speedvalues in the following way:
my_turtle.py:            'fastest' :  0
my_turtle.py:            'fast'    :  10
my_turtle.py:            'normal'  :  6
my_turtle.py:            'slow'    :  3
my_turtle.py:            'slowest' :  1
my_turtle.py:        speeds from 1 to 10 enforce increasingly faster animation of
my_turtle.py:        line drawing and turtle turning.
my_turtle.py:
my_turtle.py:        Attention:
my_turtle.py:        speed = 0 : *no* animation takes place. forward/back makes turtle jump
my_turtle.py:        and likewise left/right make the turtle turn instantly.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.speed(3)
my_turtle.py:        """
my_turtle.py:        speeds = {'fastest':0, 'fast':10, 'normal':6, 'slow':3, 'slowest':1 }
my_turtle.py:        if speed is None:
my_turtle.py:            return self._speed
my_turtle.py:        if speed in speeds:
my_turtle.py:            speed = speeds[speed]
my_turtle.py:        elif 0.5 < speed < 10.5:
my_turtle.py:            speed = int(round(speed))
my_turtle.py:        else:
my_turtle.py:            speed = 0
my_turtle.py:        self.pen(speed=speed)
my_turtle.py:
my_turtle.py:    def color(self, *args):
my_turtle.py:        """Return or set the pencolor and fillcolor.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        Several input formats are allowed.
my_turtle.py:        They use 0, 1, 2, or 3 arguments as follows:
my_turtle.py:
my_turtle.py:        color()
my_turtle.py:            Return the current pencolor and the current fillcolor
my_turtle.py:            as a pair of color specification strings as are returned
my_turtle.py:            by pencolor and fillcolor.
my_turtle.py:        color(colorstring), color((r,g,b)), color(r,g,b)
my_turtle.py:            inputs as in pencolor, set both, fillcolor and pencolor,
my_turtle.py:            to the given value.
my_turtle.py:        color(colorstring1, colorstring2),
my_turtle.py:        color((r1,g1,b1), (r2,g2,b2))
my_turtle.py:            equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
my_turtle.py:            and analogously, if the other input format is used.
my_turtle.py:
my_turtle.py:        If turtleshape is a polygon, outline and interior of that polygon
my_turtle.py:        is drawn with the newly set colors.
my_turtle.py:        For mor info see: pencolor, fillcolor
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.color('red', 'green')
my_turtle.py:        >>> turtle.color()
my_turtle.py:        ('red', 'green')
my_turtle.py:        >>> colormode(255)
my_turtle.py:        >>> color((40, 80, 120), (160, 200, 240))
my_turtle.py:        >>> color()
my_turtle.py:        ('#285078', '#a0c8f0')
my_turtle.py:        """
my_turtle.py:        if args:
my_turtle.py:            l = len(args)
my_turtle.py:            if l == 1:
my_turtle.py:                pcolor = fcolor = args[0]
my_turtle.py:            elif l == 2:
my_turtle.py:                pcolor, fcolor = args
my_turtle.py:            elif l == 3:
my_turtle.py:                pcolor = fcolor = args
my_turtle.py:            pcolor = self._colorstr(pcolor)
my_turtle.py:            fcolor = self._colorstr(fcolor)
my_turtle.py:            self.pen(pencolor=pcolor, fillcolor=fcolor)
my_turtle.py:        else:
my_turtle.py:            return self._color(self._pencolor), self._color(self._fillcolor)
my_turtle.py:
my_turtle.py:    def pencolor(self, *args):
my_turtle.py:        """ Return or set the pencolor.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        Four input formats are allowed:
my_turtle.py:          - pencolor()
my_turtle.py:            Return the current pencolor as color specification string,
my_turtle.py:            possibly in hex-number format (see example).
my_turtle.py:            May be used as input to another color/pencolor/fillcolor call.
my_turtle.py:          - pencolor(colorstring)
my_turtle.py:            s is a Tk color specification string, such as "red" or "yellow"
my_turtle.py:          - pencolor((r, g, b))
my_turtle.py:            *a tuple* of r, g, and b, which represent, an RGB color,
my_turtle.py:            and each of r, g, and b are in the range 0..colormode,
my_turtle.py:            where colormode is either 1.0 or 255
my_turtle.py:          - pencolor(r, g, b)
my_turtle.py:            r, g, and b represent an RGB color, and each of r, g, and b
my_turtle.py:            are in the range 0..colormode
my_turtle.py:
my_turtle.py:        If turtleshape is a polygon, the outline of that polygon is drawn
my_turtle.py:        with the newly set pencolor.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pencolor('brown')
my_turtle.py:        >>> tup = (0.2, 0.8, 0.55)
my_turtle.py:        >>> turtle.pencolor(tup)
my_turtle.py:        >>> turtle.pencolor()
my_turtle.py:        '#33cc8c'
my_turtle.py:        """
my_turtle.py:        if args:
my_turtle.py:            color = self._colorstr(args)
my_turtle.py:            if color == self._pencolor:
my_turtle.py:                return
my_turtle.py:            self.pen(pencolor=color)
my_turtle.py:        else:
my_turtle.py:            return self._color(self._pencolor)
my_turtle.py:
my_turtle.py:    def fillcolor(self, *args):
my_turtle.py:        """ Return or set the fillcolor.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        Four input formats are allowed:
my_turtle.py:          - fillcolor()
my_turtle.py:            Return the current fillcolor as color specification string,
my_turtle.py:            possibly in hex-number format (see example).
my_turtle.py:            May be used as input to another color/pencolor/fillcolor call.
my_turtle.py:          - fillcolor(colorstring)
my_turtle.py:            s is a Tk color specification string, such as "red" or "yellow"
my_turtle.py:          - fillcolor((r, g, b))
my_turtle.py:            *a tuple* of r, g, and b, which represent, an RGB color,
my_turtle.py:            and each of r, g, and b are in the range 0..colormode,
my_turtle.py:            where colormode is either 1.0 or 255
my_turtle.py:          - fillcolor(r, g, b)
my_turtle.py:            r, g, and b represent an RGB color, and each of r, g, and b
my_turtle.py:            are in the range 0..colormode
my_turtle.py:
my_turtle.py:        If turtleshape is a polygon, the interior of that polygon is drawn
my_turtle.py:        with the newly set fillcolor.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.fillcolor('violet')
my_turtle.py:        >>> col = turtle.pencolor()
my_turtle.py:        >>> turtle.fillcolor(col)
my_turtle.py:        >>> turtle.fillcolor(0, .5, 0)
my_turtle.py:        """
my_turtle.py:        if args:
my_turtle.py:            color = self._colorstr(args)
my_turtle.py:            if color == self._fillcolor:
my_turtle.py:                return
my_turtle.py:            self.pen(fillcolor=color)
my_turtle.py:        else:
my_turtle.py:            return self._color(self._fillcolor)
my_turtle.py:
my_turtle.py:    def showturtle(self):
my_turtle.py:        """Makes the turtle visible.
my_turtle.py:
my_turtle.py:        Aliases: showturtle | st
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.hideturtle()
my_turtle.py:        >>> turtle.showturtle()
my_turtle.py:        """
my_turtle.py:        self.pen(shown=True)
my_turtle.py:
my_turtle.py:    def hideturtle(self):
my_turtle.py:        """Makes the turtle invisible.
my_turtle.py:
my_turtle.py:        Aliases: hideturtle | ht
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        It's a good idea to do this while you're in the
my_turtle.py:        middle of a complicated drawing, because hiding
my_turtle.py:        the turtle speeds up the drawing observably.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.hideturtle()
my_turtle.py:        """
my_turtle.py:        self.pen(shown=False)
my_turtle.py:
my_turtle.py:    def isvisible(self):
my_turtle.py:        """Return True if the Turtle is shown, False if it's hidden.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.hideturtle()
my_turtle.py:        >>> print turtle.isvisible():
my_turtle.py:        False
my_turtle.py:        """
my_turtle.py:        return self._shown
my_turtle.py:
my_turtle.py:    def pen(self, pen=None, **pendict):
my_turtle.py:        """Return or set the pen's attributes.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:            pen -- a dictionary with some or all of the below listed keys.
my_turtle.py:            **pendict -- one or more keyword-arguments with the below
my_turtle.py:                         listed keys as keywords.
my_turtle.py:
my_turtle.py:        Return or set the pen's attributes in a 'pen-dictionary'
my_turtle.py:        with the following key/value pairs:
my_turtle.py:           "shown"      :   True/False
my_turtle.py:           "pendown"    :   True/False
my_turtle.py:           "pencolor"   :   color-string or color-tuple
my_turtle.py:           "fillcolor"  :   color-string or color-tuple
my_turtle.py:           "pensize"    :   positive number
my_turtle.py:           "speed"      :   number in range 0..10
my_turtle.py:           "resizemode" :   "auto" or "user" or "noresize"
my_turtle.py:           "stretchfactor": (positive number, positive number)
my_turtle.py:           "shearfactor":   number
my_turtle.py:           "outline"    :   positive number
my_turtle.py:           "tilt"       :   number
my_turtle.py:
my_turtle.py:        This dictionary can be used as argument for a subsequent
my_turtle.py:        pen()-call to restore the former pen-state. Moreover one
my_turtle.py:        or more of these attributes can be provided as keyword-arguments.
my_turtle.py:        This can be used to set several pen attributes in one statement.
my_turtle.py:
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.pen(fillcolor="black", pencolor="red", pensize=10)
my_turtle.py:        >>> turtle.pen()
my_turtle.py:        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
my_turtle.py:        'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',
my_turtle.py:        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
my_turtle.py:        >>> penstate=turtle.pen()
my_turtle.py:        >>> turtle.color("yellow","")
my_turtle.py:        >>> turtle.penup()
my_turtle.py:        >>> turtle.pen()
my_turtle.py:        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
my_turtle.py:        'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',
my_turtle.py:        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
my_turtle.py:        >>> p.pen(penstate, fillcolor="green")
my_turtle.py:        >>> p.pen()
my_turtle.py:        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
my_turtle.py:        'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',
my_turtle.py:        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
my_turtle.py:        """
my_turtle.py:        _pd =  {"shown"         : self._shown,
my_turtle.py:                "pendown"       : self._drawing,
my_turtle.py:                "pencolor"      : self._pencolor,
my_turtle.py:                "fillcolor"     : self._fillcolor,
my_turtle.py:                "pensize"       : self._pensize,
my_turtle.py:                "speed"         : self._speed,
my_turtle.py:                "resizemode"    : self._resizemode,
my_turtle.py:                "stretchfactor" : self._stretchfactor,
my_turtle.py:                "shearfactor"   : self._shearfactor,
my_turtle.py:                "outline"       : self._outlinewidth,
my_turtle.py:                "tilt"          : self._tilt
my_turtle.py:               }
my_turtle.py:
my_turtle.py:        if not (pen or pendict):
my_turtle.py:            return _pd
my_turtle.py:
my_turtle.py:        if isinstance(pen, dict):
my_turtle.py:            p = pen
my_turtle.py:        else:
my_turtle.py:            p = {}
my_turtle.py:        p.update(pendict)
my_turtle.py:
my_turtle.py:        _p_buf = {}
my_turtle.py:        for key in p:
my_turtle.py:            _p_buf[key] = _pd[key]
my_turtle.py:
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(("pen", _p_buf))
my_turtle.py:
my_turtle.py:        newLine = False
my_turtle.py:        if "pendown" in p:
my_turtle.py:            if self._drawing != p["pendown"]:
my_turtle.py:                newLine = True
my_turtle.py:        if "pencolor" in p:
my_turtle.py:            if isinstance(p["pencolor"], tuple):
my_turtle.py:                p["pencolor"] = self._colorstr((p["pencolor"],))
my_turtle.py:            if self._pencolor != p["pencolor"]:
my_turtle.py:                newLine = True
my_turtle.py:        if "pensize" in p:
my_turtle.py:            if self._pensize != p["pensize"]:
my_turtle.py:                newLine = True
my_turtle.py:        if newLine:
my_turtle.py:            self._newLine()
my_turtle.py:        if "pendown" in p:
my_turtle.py:            self._drawing = p["pendown"]
my_turtle.py:        if "pencolor" in p:
my_turtle.py:            self._pencolor = p["pencolor"]
my_turtle.py:        if "pensize" in p:
my_turtle.py:            self._pensize = p["pensize"]
my_turtle.py:        if "fillcolor" in p:
my_turtle.py:            if isinstance(p["fillcolor"], tuple):
my_turtle.py:                p["fillcolor"] = self._colorstr((p["fillcolor"],))
my_turtle.py:            self._fillcolor = p["fillcolor"]
my_turtle.py:        if "speed" in p:
my_turtle.py:            self._speed = p["speed"]
my_turtle.py:        if "resizemode" in p:
my_turtle.py:            self._resizemode = p["resizemode"]
my_turtle.py:        if "stretchfactor" in p:
my_turtle.py:            sf = p["stretchfactor"]
my_turtle.py:            if isinstance(sf, (int, float)):
my_turtle.py:                sf = (sf, sf)
my_turtle.py:            self._stretchfactor = sf
my_turtle.py:        if "shearfactor" in p:
my_turtle.py:            self._shearfactor = p["shearfactor"]
my_turtle.py:        if "outline" in p:
my_turtle.py:            self._outlinewidth = p["outline"]
my_turtle.py:        if "shown" in p:
my_turtle.py:            self._shown = p["shown"]
my_turtle.py:        if "tilt" in p:
my_turtle.py:            self._tilt = p["tilt"]
my_turtle.py:        if "stretchfactor" in p or "tilt" in p or "shearfactor" in p:
my_turtle.py:            scx, scy = self._stretchfactor
my_turtle.py:            shf = self._shearfactor
my_turtle.py:            sa, ca = math.sin(self._tilt), math.cos(self._tilt)
my_turtle.py:            self._shapetrafo = ( scx*ca, scy*(shf*ca + sa),
my_turtle.py:                                -scx*sa, scy*(ca - shf*sa))
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:## three dummy methods to be implemented by child class:
my_turtle.py:
my_turtle.py:    def _newLine(self, usePos = True):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:    def _update(self, count=True, forced=False):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:    def _color(self, args):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:    def _colorstr(self, args):
my_turtle.py:        """dummy method - to be overwritten by child class"""
my_turtle.py:
my_turtle.py:    width = pensize
my_turtle.py:    up = penup
my_turtle.py:    pu = penup
my_turtle.py:    pd = pendown
my_turtle.py:    down = pendown
my_turtle.py:    st = showturtle
my_turtle.py:    ht = hideturtle
my_turtle.py:
my_turtle.py:
my_turtle.py:class _TurtleImage(object):
my_turtle.py:    """Helper class: Datatype to store Turtle attributes
my_turtle.py:    """
my_turtle.py:
my_turtle.py:    def __init__(self, screen, shapeIndex):
my_turtle.py:        self.screen = screen
my_turtle.py:        self._type = None
my_turtle.py:        self._setshape(shapeIndex)
my_turtle.py:
my_turtle.py:    def _setshape(self, shapeIndex):
my_turtle.py:        screen = self.screen
my_turtle.py:        self.shapeIndex = shapeIndex
my_turtle.py:        if self._type == "polygon" == screen._shapes[shapeIndex]._type:
my_turtle.py:            return
my_turtle.py:        if self._type == "image" == screen._shapes[shapeIndex]._type:
my_turtle.py:            return
my_turtle.py:        if self._type in ["image", "polygon"]:
my_turtle.py:            screen._delete(self._item)
my_turtle.py:        elif self._type == "compound":
my_turtle.py:            for item in self._item:
my_turtle.py:                screen._delete(item)
my_turtle.py:        self._type = screen._shapes[shapeIndex]._type
my_turtle.py:        if self._type == "polygon":
my_turtle.py:            self._item = screen._createpoly()
my_turtle.py:        elif self._type == "image":
my_turtle.py:            self._item = screen._createimage(screen._shapes["blank"]._data)
my_turtle.py:        elif self._type == "compound":
my_turtle.py:            self._item = [screen._createpoly() for item in
my_turtle.py:                                          screen._shapes[shapeIndex]._data]
my_turtle.py:
my_turtle.py:
my_turtle.py:class RawTurtle(TPen, TNavigator):
my_turtle.py:    """Animation part of the RawTurtle.
my_turtle.py:    Puts RawTurtle upon a TurtleScreen and provides tools for
my_turtle.py:    its animation.
my_turtle.py:    """
my_turtle.py:    screens = []
my_turtle.py:
my_turtle.py:    def __init__(self, canvas=None,
my_turtle.py:                 shape=_CFG["shape"],
my_turtle.py:                 undobuffersize=_CFG["undobuffersize"],
my_turtle.py:                 visible=_CFG["visible"],
my_turtle.py:                 name=None):
my_turtle.py:        if isinstance(canvas, _Screen):
my_turtle.py:            self.screen = canvas
my_turtle.py:        elif isinstance(canvas, TurtleScreen):
my_turtle.py:            if canvas not in RawTurtle.screens:
my_turtle.py:                RawTurtle.screens.append(canvas)
my_turtle.py:            self.screen = canvas
my_turtle.py:        elif isinstance(canvas, (ScrolledCanvas, Canvas)):
my_turtle.py:            for screen in RawTurtle.screens:
my_turtle.py:                if screen.cv == canvas:
my_turtle.py:                    self.screen = screen
my_turtle.py:                    break
my_turtle.py:            else:
my_turtle.py:                self.screen = TurtleScreen(canvas)
my_turtle.py:                RawTurtle.screens.append(self.screen)
my_turtle.py:        else:
my_turtle.py:            raise TurtleGraphicsError("bad canvas argument %s" % canvas)
my_turtle.py:        if not(name is None):
my_turtle.py:            self.name = name
my_turtle.py:
my_turtle.py:        screen = self.screen
my_turtle.py:        TNavigator.__init__(self, screen.mode())
my_turtle.py:        TPen.__init__(self)
my_turtle.py:        screen._turtles.append(self)
my_turtle.py:        self.drawingLineItem = screen._createline()
my_turtle.py:        self.turtle = _TurtleImage(screen, shape)
my_turtle.py:        self._poly = None
my_turtle.py:        self._creatingPoly = False
my_turtle.py:        self._fillitem = self._fillpath = None
my_turtle.py:        self._shown = visible
my_turtle.py:        self._hidden_from_screen = False
my_turtle.py:        self.currentLineItem = screen._createline()
my_turtle.py:        self.currentLine = [self._position]
my_turtle.py:        self.items = [self.currentLineItem]
my_turtle.py:        self.stampItems = []
my_turtle.py:        self._undobuffersize = undobuffersize
my_turtle.py:        self.undobuffer = Tbuffer(undobuffersize)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def reset(self):
my_turtle.py:        """Delete the turtle's drawings and restore its default values.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Delete the turtle's drawings from the screen, re-center the turtle
my_turtle.py:        and set variables to the default values.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00,-22.00)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        100.0
my_turtle.py:        >>> turtle.reset()
my_turtle.py:        >>> turtle.position()
my_turtle.py:        (0.00,0.00)
my_turtle.py:        >>> turtle.heading()
my_turtle.py:        0.0
my_turtle.py:        """
my_turtle.py:        TNavigator.reset(self)
my_turtle.py:        TPen._reset(self)
my_turtle.py:        self._clear()
my_turtle.py:        self._drawturtle()
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def setundobuffer(self, size):
my_turtle.py:        """Set or disable undobuffer.
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        size -- an integer or None
my_turtle.py:
my_turtle.py:        If size is an integer an empty undobuffer of given size is installed.
my_turtle.py:        Size gives the maximum number of turtle-actions that can be undone
my_turtle.py:        by the undo() function.
my_turtle.py:        If size is None, no undobuffer is present.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.setundobuffer(42)
my_turtle.py:        """
my_turtle.py:        if size is None or size <= 0:
my_turtle.py:            self.undobuffer = None
my_turtle.py:        else:
my_turtle.py:            self.undobuffer = Tbuffer(size)
my_turtle.py:
my_turtle.py:    def undobufferentries(self):
my_turtle.py:        """Return count of entries in the undobuffer.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> while undobufferentries():
my_turtle.py:        ...     undo()
my_turtle.py:        """
my_turtle.py:        if self.undobuffer is None:
my_turtle.py:            return 0
my_turtle.py:        return self.undobuffer.nr_of_items()
my_turtle.py:
my_turtle.py:    def _clear(self):
my_turtle.py:        """Delete all of pen's drawings"""
my_turtle.py:        self._fillitem = self._fillpath = None
my_turtle.py:        for item in self.items:
my_turtle.py:            self.screen._delete(item)
my_turtle.py:        self.currentLineItem = self.screen._createline()
my_turtle.py:        self.currentLine = []
my_turtle.py:        if self._drawing:
my_turtle.py:            self.currentLine.append(self._position)
my_turtle.py:        self.items = [self.currentLineItem]
my_turtle.py:        self.clearstamps()
my_turtle.py:        self.setundobuffer(self._undobuffersize)
my_turtle.py:
my_turtle.py:
my_turtle.py:    def clear(self):
my_turtle.py:        """Delete the turtle's drawings from the screen. Do not move turtle.
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Delete the turtle's drawings from the screen. Do not move turtle.
my_turtle.py:        State and position of the turtle as well as drawings of other
my_turtle.py:        turtles are not affected.
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.clear()
my_turtle.py:        """
my_turtle.py:        self._clear()
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def _update_data(self):
my_turtle.py:        self.screen._incrementudc()
my_turtle.py:        if self.screen._updatecounter != 0:
my_turtle.py:            return
my_turtle.py:        if len(self.currentLine)>1:
my_turtle.py:            self.screen._drawline(self.currentLineItem, self.currentLine,
my_turtle.py:                                  self._pencolor, self._pensize)
my_turtle.py:
my_turtle.py:    def _update(self):
my_turtle.py:        """Perform a Turtle-data update.
my_turtle.py:        """
my_turtle.py:        screen = self.screen
my_turtle.py:        if screen._tracing == 0:
my_turtle.py:            return
my_turtle.py:        elif screen._tracing == 1:
my_turtle.py:            self._update_data()
my_turtle.py:            self._drawturtle()
my_turtle.py:            screen._update()                  # TurtleScreenBase
my_turtle.py:            screen._delay(screen._delayvalue) # TurtleScreenBase
my_turtle.py:        else:
my_turtle.py:            self._update_data()
my_turtle.py:            if screen._updatecounter == 0:
my_turtle.py:                for t in screen.turtles():
my_turtle.py:                    t._drawturtle()
my_turtle.py:                screen._update()
my_turtle.py:
my_turtle.py:    def _tracer(self, flag=None, delay=None):
my_turtle.py:        """Turns turtle animation on/off and set delay for update drawings.
my_turtle.py:
my_turtle.py:        Optional arguments:
my_turtle.py:        n -- nonnegative  integer
my_turtle.py:        delay -- nonnegative  integer
my_turtle.py:
my_turtle.py:        If n is given, only each n-th regular screen update is really performed.
my_turtle.py:        (Can be used to accelerate the drawing of complex graphics.)
my_turtle.py:        Second arguments sets delay value (see RawTurtle.delay())
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.tracer(8, 25)
my_turtle.py:        >>> dist = 2
my_turtle.py:        >>> for i in range(200):
my_turtle.py:        ...     turtle.fd(dist)
my_turtle.py:        ...     turtle.rt(90)
my_turtle.py:        ...     dist += 2
my_turtle.py:        """
my_turtle.py:        return self.screen.tracer(flag, delay)
my_turtle.py:
my_turtle.py:    def _color(self, args):
my_turtle.py:        return self.screen._color(args)
my_turtle.py:
my_turtle.py:    def _colorstr(self, args):
my_turtle.py:        return self.screen._colorstr(args)
my_turtle.py:
my_turtle.py:    def _cc(self, args):
my_turtle.py:        """Convert colortriples to hexstrings.
my_turtle.py:        """
my_turtle.py:        if isinstance(args, str):
my_turtle.py:            return args
my_turtle.py:        try:
my_turtle.py:            r, g, b = args
my_turtle.py:        except:
my_turtle.py:            raise TurtleGraphicsError("bad color arguments: %s" % str(args))
my_turtle.py:        if self.screen._colormode == 1.0:
my_turtle.py:            r, g, b = [round(255.0*x) for x in (r, g, b)]
my_turtle.py:        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
my_turtle.py:            raise TurtleGraphicsError("bad color sequence: %s" % str(args))
my_turtle.py:        return "#%02x%02x%02x" % (r, g, b)
my_turtle.py:
my_turtle.py:    def clone(self):
my_turtle.py:        """Create and return a clone of the turtle.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Create and return a clone of the turtle with same position, heading
my_turtle.py:        and turtle properties.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named mick):
my_turtle.py:        mick = Turtle()
my_turtle.py:        joe = mick.clone()
my_turtle.py:        """
my_turtle.py:        screen = self.screen
my_turtle.py:        self._newLine(self._drawing)
my_turtle.py:
my_turtle.py:        turtle = self.turtle
my_turtle.py:        self.screen = None
my_turtle.py:        self.turtle = None  # too make self deepcopy-able
my_turtle.py:
my_turtle.py:        q = deepcopy(self)
my_turtle.py:
my_turtle.py:        self.screen = screen
my_turtle.py:        self.turtle = turtle
my_turtle.py:
my_turtle.py:        q.screen = screen
my_turtle.py:        q.turtle = _TurtleImage(screen, self.turtle.shapeIndex)
my_turtle.py:
my_turtle.py:        screen._turtles.append(q)
my_turtle.py:        ttype = screen._shapes[self.turtle.shapeIndex]._type
my_turtle.py:        if ttype == "polygon":
my_turtle.py:            q.turtle._item = screen._createpoly()
my_turtle.py:        elif ttype == "image":
my_turtle.py:            q.turtle._item = screen._createimage(screen._shapes["blank"]._data)
my_turtle.py:        elif ttype == "compound":
my_turtle.py:            q.turtle._item = [screen._createpoly() for item in
my_turtle.py:                              screen._shapes[self.turtle.shapeIndex]._data]
my_turtle.py:        q.currentLineItem = screen._createline()
my_turtle.py:        q._update()
my_turtle.py:        return q
my_turtle.py:
my_turtle.py:    def shape(self, name=None):
my_turtle.py:        """Set turtle shape to shape with given name / return current shapename.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        name -- a string, which is a valid shapename
my_turtle.py:
my_turtle.py:        Set turtle shape to shape with given name or, if name is not given,
my_turtle.py:        return name of current shape.
my_turtle.py:        Shape with name must exist in the TurtleScreen's shape dictionary.
my_turtle.py:        Initially there are the following polygon shapes:
my_turtle.py:        'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.
my_turtle.py:        To learn about how to deal with shapes see Screen-method register_shape.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape()
my_turtle.py:        'arrow'
my_turtle.py:        >>> turtle.shape("turtle")
my_turtle.py:        >>> turtle.shape()
my_turtle.py:        'turtle'
my_turtle.py:        """
my_turtle.py:        if name is None:
my_turtle.py:            return self.turtle.shapeIndex
my_turtle.py:        if not name in self.screen.getshapes():
my_turtle.py:            raise TurtleGraphicsError("There is no shape named %s" % name)
my_turtle.py:        self.turtle._setshape(name)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):
my_turtle.py:        """Set/return turtle's stretchfactors/outline. Set resizemode to "user".
my_turtle.py:
my_turtle.py:        Optional arguments:
my_turtle.py:           stretch_wid : positive number
my_turtle.py:           stretch_len : positive number
my_turtle.py:           outline  : positive number
my_turtle.py:
my_turtle.py:        Return or set the pen's attributes x/y-stretchfactors and/or outline.
my_turtle.py:        Set resizemode to "user".
my_turtle.py:        If and only if resizemode is set to "user", the turtle will be displayed
my_turtle.py:        stretched according to its stretchfactors:
my_turtle.py:        stretch_wid is stretchfactor perpendicular to orientation
my_turtle.py:        stretch_len is stretchfactor in direction of turtles orientation.
my_turtle.py:        outline determines the width of the shapes's outline.
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.resizemode("user")
my_turtle.py:        >>> turtle.shapesize(5, 5, 12)
my_turtle.py:        >>> turtle.shapesize(outline=8)
my_turtle.py:        """
my_turtle.py:        if stretch_wid is stretch_len is outline is None:
my_turtle.py:            stretch_wid, stretch_len = self._stretchfactor
my_turtle.py:            return stretch_wid, stretch_len, self._outlinewidth
my_turtle.py:        if stretch_wid == 0 or stretch_len == 0:
my_turtle.py:            raise TurtleGraphicsError("stretch_wid/stretch_len must not be zero")
my_turtle.py:        if stretch_wid is not None:
my_turtle.py:            if stretch_len is None:
my_turtle.py:                stretchfactor = stretch_wid, stretch_wid
my_turtle.py:            else:
my_turtle.py:                stretchfactor = stretch_wid, stretch_len
my_turtle.py:        elif stretch_len is not None:
my_turtle.py:            stretchfactor = self._stretchfactor[0], stretch_len
my_turtle.py:        else:
my_turtle.py:            stretchfactor = self._stretchfactor
my_turtle.py:        if outline is None:
my_turtle.py:            outline = self._outlinewidth
my_turtle.py:        self.pen(resizemode="user",
my_turtle.py:                 stretchfactor=stretchfactor, outline=outline)
my_turtle.py:
my_turtle.py:    def shearfactor(self, shear=None):
my_turtle.py:        """Set or return the current shearfactor.
my_turtle.py:
my_turtle.py:        Optional argument: shear -- number, tangent of the shear angle
my_turtle.py:
my_turtle.py:        Shear the turtleshape according to the given shearfactor shear,
my_turtle.py:        which is the tangent of the shear angle. DO NOT change the
my_turtle.py:        turtle's heading (direction of movement).
my_turtle.py:        If shear is not given: return the current shearfactor, i. e. the
my_turtle.py:        tangent of the shear angle, by which lines parallel to the
my_turtle.py:        heading of the turtle are sheared.
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("circle")
my_turtle.py:        >>> turtle.shapesize(5,2)
my_turtle.py:        >>> turtle.shearfactor(0.5)
my_turtle.py:        >>> turtle.shearfactor()
my_turtle.py:        >>> 0.5
my_turtle.py:        """
my_turtle.py:        if shear is None:
my_turtle.py:            return self._shearfactor
my_turtle.py:        self.pen(resizemode="user", shearfactor=shear)
my_turtle.py:
my_turtle.py:    def settiltangle(self, angle):
my_turtle.py:        """Rotate the turtleshape to point in the specified direction
my_turtle.py:
my_turtle.py:        Argument: angle -- number
my_turtle.py:
my_turtle.py:        Rotate the turtleshape to point in the direction specified by angle,
my_turtle.py:        regardless of its current tilt-angle. DO NOT change the turtle's
my_turtle.py:        heading (direction of movement).
my_turtle.py:
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("circle")
my_turtle.py:        >>> turtle.shapesize(5,2)
my_turtle.py:        >>> turtle.settiltangle(45)
my_turtle.py:        >>> stamp()
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        >>> turtle.settiltangle(-45)
my_turtle.py:        >>> stamp()
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        """
my_turtle.py:        tilt = -angle * self._degreesPerAU * self._angleOrient
my_turtle.py:        tilt = (tilt * math.pi / 180.0) % (2*math.pi)
my_turtle.py:        self.pen(resizemode="user", tilt=tilt)
my_turtle.py:
my_turtle.py:    def tiltangle(self, angle=None):
my_turtle.py:        """Set or return the current tilt-angle.
my_turtle.py:
my_turtle.py:        Optional argument: angle -- number
my_turtle.py:
my_turtle.py:        Rotate the turtleshape to point in the direction specified by angle,
my_turtle.py:        regardless of its current tilt-angle. DO NOT change the turtle's
my_turtle.py:        heading (direction of movement).
my_turtle.py:        If angle is not given: return the current tilt-angle, i. e. the angle
my_turtle.py:        between the orientation of the turtleshape and the heading of the
my_turtle.py:        turtle (its direction of movement).
my_turtle.py:
my_turtle.py:        Deprecated since Python 3.1
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("circle")
my_turtle.py:        >>> turtle.shapesize(5,2)
my_turtle.py:        >>> turtle.tilt(45)
my_turtle.py:        >>> turtle.tiltangle()
my_turtle.py:        """
my_turtle.py:        if angle is None:
my_turtle.py:            tilt = -self._tilt * (180.0/math.pi) * self._angleOrient
my_turtle.py:            return (tilt / self._degreesPerAU) % self._fullcircle
my_turtle.py:        else:
my_turtle.py:            self.settiltangle(angle)
my_turtle.py:
my_turtle.py:    def tilt(self, angle):
my_turtle.py:        """Rotate the turtleshape by angle.
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        angle - a number
my_turtle.py:
my_turtle.py:        Rotate the turtleshape by angle from its current tilt-angle,
my_turtle.py:        but do NOT change the turtle's heading (direction of movement).
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("circle")
my_turtle.py:        >>> turtle.shapesize(5,2)
my_turtle.py:        >>> turtle.tilt(30)
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        >>> turtle.tilt(30)
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        """
my_turtle.py:        self.settiltangle(angle + self.tiltangle())
my_turtle.py:
my_turtle.py:    def shapetransform(self, t11=None, t12=None, t21=None, t22=None):
my_turtle.py:        """Set or return the current transformation matrix of the turtle shape.
my_turtle.py:
my_turtle.py:        Optional arguments: t11, t12, t21, t22 -- numbers.
my_turtle.py:
my_turtle.py:        If none of the matrix elements are given, return the transformation
my_turtle.py:        matrix.
my_turtle.py:        Otherwise set the given elements and transform the turtleshape
my_turtle.py:        according to the matrix consisting of first row t11, t12 and
my_turtle.py:        second row t21, 22.
my_turtle.py:        Modify stretchfactor, shearfactor and tiltangle according to the
my_turtle.py:        given matrix.
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("square")
my_turtle.py:        >>> turtle.shapesize(4,2)
my_turtle.py:        >>> turtle.shearfactor(-0.5)
my_turtle.py:        >>> turtle.shapetransform()
my_turtle.py:        (4.0, -1.0, -0.0, 2.0)
my_turtle.py:        """
my_turtle.py:        if t11 is t12 is t21 is t22 is None:
my_turtle.py:            return self._shapetrafo
my_turtle.py:        m11, m12, m21, m22 = self._shapetrafo
my_turtle.py:        if t11 is not None: m11 = t11
my_turtle.py:        if t12 is not None: m12 = t12
my_turtle.py:        if t21 is not None: m21 = t21
my_turtle.py:        if t22 is not None: m22 = t22
my_turtle.py:        if t11 * t22 - t12 * t21 == 0:
my_turtle.py:            raise TurtleGraphicsError("Bad shape transform matrix: must not be singular")
my_turtle.py:        self._shapetrafo = (m11, m12, m21, m22)
my_turtle.py:        alfa = math.atan2(-m21, m11) % (2 * math.pi)
my_turtle.py:        sa, ca = math.sin(alfa), math.cos(alfa)
my_turtle.py:        a11, a12, a21, a22 = (ca*m11 - sa*m21, ca*m12 - sa*m22,
my_turtle.py:                              sa*m11 + ca*m21, sa*m12 + ca*m22)
my_turtle.py:        self._stretchfactor = a11, a22
my_turtle.py:        self._shearfactor = a12/a22
my_turtle.py:        self._tilt = alfa
my_turtle.py:        self.pen(resizemode="user")
my_turtle.py:
my_turtle.py:
my_turtle.py:    def _polytrafo(self, poly):
my_turtle.py:        """Computes transformed polygon shapes from a shape
my_turtle.py:        according to current position and heading.
my_turtle.py:        """
my_turtle.py:        screen = self.screen
my_turtle.py:        p0, p1 = self._position
my_turtle.py:        e0, e1 = self._orient
my_turtle.py:        e = Vec2D(e0, e1 * screen.yscale / screen.xscale)
my_turtle.py:        e0, e1 = (1.0 / abs(e)) * e
my_turtle.py:        return [(p0+(e1*x+e0*y)/screen.xscale, p1+(-e0*x+e1*y)/screen.yscale)
my_turtle.py:                                                           for (x, y) in poly]
my_turtle.py:
my_turtle.py:    def get_shapepoly(self):
my_turtle.py:        """Return the current shape polygon as tuple of coordinate pairs.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Examples (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.shape("square")
my_turtle.py:        >>> turtle.shapetransform(4, -1, 0, 2)
my_turtle.py:        >>> turtle.get_shapepoly()
my_turtle.py:        ((50, -20), (30, 20), (-50, 20), (-30, -20))
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        shape = self.screen._shapes[self.turtle.shapeIndex]
my_turtle.py:        if shape._type == "polygon":
my_turtle.py:            return self._getshapepoly(shape._data, shape._type == "compound")
my_turtle.py:        # else return None
my_turtle.py:
my_turtle.py:    def _getshapepoly(self, polygon, compound=False):
my_turtle.py:        """Calculate transformed shape polygon according to resizemode
my_turtle.py:        and shapetransform.
my_turtle.py:        """
my_turtle.py:        if self._resizemode == "user" or compound:
my_turtle.py:            t11, t12, t21, t22 = self._shapetrafo
my_turtle.py:        elif self._resizemode == "auto":
my_turtle.py:            l = max(1, self._pensize/5.0)
my_turtle.py:            t11, t12, t21, t22 = l, 0, 0, l
my_turtle.py:        elif self._resizemode == "noresize":
my_turtle.py:            return polygon
my_turtle.py:        return tuple([(t11*x + t12*y, t21*x + t22*y) for (x, y) in polygon])
my_turtle.py:
my_turtle.py:    def _drawturtle(self):
my_turtle.py:        """Manages the correct rendering of the turtle with respect to
my_turtle.py:        its shape, resizemode, stretch and tilt etc."""
my_turtle.py:        screen = self.screen
my_turtle.py:        shape = screen._shapes[self.turtle.shapeIndex]
my_turtle.py:        ttype = shape._type
my_turtle.py:        titem = self.turtle._item
my_turtle.py:        if self._shown and screen._updatecounter == 0 and screen._tracing > 0:
my_turtle.py:            self._hidden_from_screen = False
my_turtle.py:            tshape = shape._data
my_turtle.py:            if ttype == "polygon":
my_turtle.py:                if self._resizemode == "noresize": w = 1
my_turtle.py:                elif self._resizemode == "auto": w = self._pensize
my_turtle.py:                else: w =self._outlinewidth
my_turtle.py:                shape = self._polytrafo(self._getshapepoly(tshape))
my_turtle.py:                fc, oc = self._fillcolor, self._pencolor
my_turtle.py:                screen._drawpoly(titem, shape, fill=fc, outline=oc,
my_turtle.py:                                                      width=w, top=True)
my_turtle.py:            elif ttype == "image":
my_turtle.py:                screen._drawimage(titem, self._position, tshape)
my_turtle.py:            elif ttype == "compound":
my_turtle.py:                for item, (poly, fc, oc) in zip(titem, tshape):
my_turtle.py:                    poly = self._polytrafo(self._getshapepoly(poly, True))
my_turtle.py:                    screen._drawpoly(item, poly, fill=self._cc(fc),
my_turtle.py:                                     outline=self._cc(oc), width=self._outlinewidth, top=True)
my_turtle.py:        else:
my_turtle.py:            if self._hidden_from_screen:
my_turtle.py:                return
my_turtle.py:            if ttype == "polygon":
my_turtle.py:                screen._drawpoly(titem, ((0, 0), (0, 0), (0, 0)), "", "")
my_turtle.py:            elif ttype == "image":
my_turtle.py:                screen._drawimage(titem, self._position,
my_turtle.py:                                          screen._shapes["blank"]._data)
my_turtle.py:            elif ttype == "compound":
my_turtle.py:                for item in titem:
my_turtle.py:                    screen._drawpoly(item, ((0, 0), (0, 0), (0, 0)), "", "")
my_turtle.py:            self._hidden_from_screen = True
my_turtle.py:
my_turtle.py:##############################  stamp stuff  ###############################
my_turtle.py:
my_turtle.py:    def stamp(self):
my_turtle.py:        """Stamp a copy of the turtleshape onto the canvas and return its id.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Stamp a copy of the turtle shape onto the canvas at the current
my_turtle.py:        turtle position. Return a stamp_id for that stamp, which can be
my_turtle.py:        used to delete it by calling clearstamp(stamp_id).
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.color("blue")
my_turtle.py:        >>> turtle.stamp()
my_turtle.py:        13
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        """
my_turtle.py:        screen = self.screen
my_turtle.py:        shape = screen._shapes[self.turtle.shapeIndex]
my_turtle.py:        ttype = shape._type
my_turtle.py:        tshape = shape._data
my_turtle.py:        if ttype == "polygon":
my_turtle.py:            stitem = screen._createpoly()
my_turtle.py:            if self._resizemode == "noresize": w = 1
my_turtle.py:            elif self._resizemode == "auto": w = self._pensize
my_turtle.py:            else: w =self._outlinewidth
my_turtle.py:            shape = self._polytrafo(self._getshapepoly(tshape))
my_turtle.py:            fc, oc = self._fillcolor, self._pencolor
my_turtle.py:            screen._drawpoly(stitem, shape, fill=fc, outline=oc,
my_turtle.py:                                                  width=w, top=True)
my_turtle.py:        elif ttype == "image":
my_turtle.py:            stitem = screen._createimage("")
my_turtle.py:            screen._drawimage(stitem, self._position, tshape)
my_turtle.py:        elif ttype == "compound":
my_turtle.py:            stitem = []
my_turtle.py:            for element in tshape:
my_turtle.py:                item = screen._createpoly()
my_turtle.py:                stitem.append(item)
my_turtle.py:            stitem = tuple(stitem)
my_turtle.py:            for item, (poly, fc, oc) in zip(stitem, tshape):
my_turtle.py:                poly = self._polytrafo(self._getshapepoly(poly, True))
my_turtle.py:                screen._drawpoly(item, poly, fill=self._cc(fc),
my_turtle.py:                                 outline=self._cc(oc), width=self._outlinewidth, top=True)
my_turtle.py:        self.stampItems.append(stitem)
my_turtle.py:        self.undobuffer.push(("stamp", stitem))
my_turtle.py:        return stitem
my_turtle.py:
my_turtle.py:    def _clearstamp(self, stampid):
my_turtle.py:        """does the work for clearstamp() and clearstamps()
my_turtle.py:        """
my_turtle.py:        if stampid in self.stampItems:
my_turtle.py:            if isinstance(stampid, tuple):
my_turtle.py:                for subitem in stampid:
my_turtle.py:                    self.screen._delete(subitem)
my_turtle.py:            else:
my_turtle.py:                self.screen._delete(stampid)
my_turtle.py:            self.stampItems.remove(stampid)
my_turtle.py:        # Delete stampitem from undobuffer if necessary
my_turtle.py:        # if clearstamp is called directly.
my_turtle.py:        item = ("stamp", stampid)
my_turtle.py:        buf = self.undobuffer
my_turtle.py:        if item not in buf.buffer:
my_turtle.py:            return
my_turtle.py:        index = buf.buffer.index(item)
my_turtle.py:        buf.buffer.remove(item)
my_turtle.py:        if index <= buf.ptr:
my_turtle.py:            buf.ptr = (buf.ptr - 1) % buf.bufsize
my_turtle.py:        buf.buffer.insert((buf.ptr+1)%buf.bufsize, [None])
my_turtle.py:
my_turtle.py:    def clearstamp(self, stampid):
my_turtle.py:        """Delete stamp with given stampid
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        stampid - an integer, must be return value of previous stamp() call.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.color("blue")
my_turtle.py:        >>> astamp = turtle.stamp()
my_turtle.py:        >>> turtle.fd(50)
my_turtle.py:        >>> turtle.clearstamp(astamp)
my_turtle.py:        """
my_turtle.py:        self._clearstamp(stampid)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def clearstamps(self, n=None):
my_turtle.py:        """Delete all or first/last n of turtle's stamps.
my_turtle.py:
my_turtle.py:        Optional argument:
my_turtle.py:        n -- an integer
my_turtle.py:
my_turtle.py:        If n is None, delete all of pen's stamps,
my_turtle.py:        else if n > 0 delete first n stamps
my_turtle.py:        else if n < 0 delete last n stamps.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> for i in range(8):
my_turtle.py:        ...     turtle.stamp(); turtle.fd(30)
my_turtle.py:        ...
my_turtle.py:        >>> turtle.clearstamps(2)
my_turtle.py:        >>> turtle.clearstamps(-2)
my_turtle.py:        >>> turtle.clearstamps()
my_turtle.py:        """
my_turtle.py:        if n is None:
my_turtle.py:            toDelete = self.stampItems[:]
my_turtle.py:        elif n >= 0:
my_turtle.py:            toDelete = self.stampItems[:n]
my_turtle.py:        else:
my_turtle.py:            toDelete = self.stampItems[n:]
my_turtle.py:        for item in toDelete:
my_turtle.py:            self._clearstamp(item)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def _goto(self, end):
my_turtle.py:        """Move the pen to the point end, thereby drawing a line
my_turtle.py:        if pen is down. All other methods for turtle movement depend
my_turtle.py:        on this one.
my_turtle.py:        """
my_turtle.py:        ## Version with undo-stuff
my_turtle.py:        go_modes = ( self._drawing,
my_turtle.py:                     self._pencolor,
my_turtle.py:                     self._pensize,
my_turtle.py:                     isinstance(self._fillpath, list))
my_turtle.py:        screen = self.screen
my_turtle.py:        undo_entry = ("go", self._position, end, go_modes,
my_turtle.py:                      (self.currentLineItem,
my_turtle.py:                      self.currentLine[:],
my_turtle.py:                      screen._pointlist(self.currentLineItem),
my_turtle.py:                      self.items[:])
my_turtle.py:                      )
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(undo_entry)
my_turtle.py:        start = self._position
my_turtle.py:        if self._speed and screen._tracing == 1:
my_turtle.py:            diff = (end-start)
my_turtle.py:            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
my_turtle.py:            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
my_turtle.py:            delta = diff * (1.0/nhops)
my_turtle.py:            for n in range(1, nhops):
my_turtle.py:                if n == 1:
my_turtle.py:                    top = True
my_turtle.py:                else:
my_turtle.py:                    top = False
my_turtle.py:                self._position = start + delta * n
my_turtle.py:                if self._drawing:
my_turtle.py:                    screen._drawline(self.drawingLineItem,
my_turtle.py:                                     (start, self._position),
my_turtle.py:                                     self._pencolor, self._pensize, top)
my_turtle.py:                self._update()
my_turtle.py:            if self._drawing:
my_turtle.py:                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
my_turtle.py:                                               fill="", width=self._pensize)
my_turtle.py:        # Turtle now at end,
my_turtle.py:        if self._drawing: # now update currentLine
my_turtle.py:            self.currentLine.append(end)
my_turtle.py:        if isinstance(self._fillpath, list):
my_turtle.py:            self._fillpath.append(end)
my_turtle.py:        ######    vererbung!!!!!!!!!!!!!!!!!!!!!!
my_turtle.py:        self._position = end
my_turtle.py:        if self._creatingPoly:
my_turtle.py:            self._poly.append(end)
my_turtle.py:        if len(self.currentLine) > 42: # 42! answer to the ultimate question
my_turtle.py:                                       # of life, the universe and everything
my_turtle.py:            self._newLine()
my_turtle.py:        self._update() #count=True)
my_turtle.py:
my_turtle.py:    def _undogoto(self, entry):
my_turtle.py:        """Reverse a _goto. Used for undo()
my_turtle.py:        """
my_turtle.py:        old, new, go_modes, coodata = entry
my_turtle.py:        drawing, pc, ps, filling = go_modes
my_turtle.py:        cLI, cL, pl, items = coodata
my_turtle.py:        screen = self.screen
my_turtle.py:        if abs(self._position - new) > 0.5:
my_turtle.py:            print ("undogoto: HALLO-DA-STIMMT-WAS-NICHT!")
my_turtle.py:        # restore former situation
my_turtle.py:        self.currentLineItem = cLI
my_turtle.py:        self.currentLine = cL
my_turtle.py:
my_turtle.py:        if pl == [(0, 0), (0, 0)]:
my_turtle.py:            usepc = ""
my_turtle.py:        else:
my_turtle.py:            usepc = pc
my_turtle.py:        screen._drawline(cLI, pl, fill=usepc, width=ps)
my_turtle.py:
my_turtle.py:        todelete = [i for i in self.items if (i not in items) and
my_turtle.py:                                       (screen._type(i) == "line")]
my_turtle.py:        for i in todelete:
my_turtle.py:            screen._delete(i)
my_turtle.py:            self.items.remove(i)
my_turtle.py:
my_turtle.py:        start = old
my_turtle.py:        if self._speed and screen._tracing == 1:
my_turtle.py:            diff = old - new
my_turtle.py:            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
my_turtle.py:            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
my_turtle.py:            delta = diff * (1.0/nhops)
my_turtle.py:            for n in range(1, nhops):
my_turtle.py:                if n == 1:
my_turtle.py:                    top = True
my_turtle.py:                else:
my_turtle.py:                    top = False
my_turtle.py:                self._position = new + delta * n
my_turtle.py:                if drawing:
my_turtle.py:                    screen._drawline(self.drawingLineItem,
my_turtle.py:                                     (start, self._position),
my_turtle.py:                                     pc, ps, top)
my_turtle.py:                self._update()
my_turtle.py:            if drawing:
my_turtle.py:                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
my_turtle.py:                                               fill="", width=ps)
my_turtle.py:        # Turtle now at position old,
my_turtle.py:        self._position = old
my_turtle.py:        ##  if undo is done during creating a polygon, the last vertex
my_turtle.py:        ##  will be deleted. if the polygon is entirely deleted,
my_turtle.py:        ##  creatingPoly will be set to False.
my_turtle.py:        ##  Polygons created before the last one will not be affected by undo()
my_turtle.py:        if self._creatingPoly:
my_turtle.py:            if len(self._poly) > 0:
my_turtle.py:                self._poly.pop()
my_turtle.py:            if self._poly == []:
my_turtle.py:                self._creatingPoly = False
my_turtle.py:                self._poly = None
my_turtle.py:        if filling:
my_turtle.py:            if self._fillpath == []:
my_turtle.py:                self._fillpath = None
my_turtle.py:                print("Unwahrscheinlich in _undogoto!")
my_turtle.py:            elif self._fillpath is not None:
my_turtle.py:                self._fillpath.pop()
my_turtle.py:        self._update() #count=True)
my_turtle.py:
my_turtle.py:    def _rotate(self, angle):
my_turtle.py:        """Turns pen clockwise by angle.
my_turtle.py:        """
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(("rot", angle, self._degreesPerAU))
my_turtle.py:        angle *= self._degreesPerAU
my_turtle.py:        neworient = self._orient.rotate(angle)
my_turtle.py:        tracing = self.screen._tracing
my_turtle.py:        if tracing == 1 and self._speed > 0:
my_turtle.py:            anglevel = 3.0 * self._speed
my_turtle.py:            steps = 1 + int(abs(angle)/anglevel)
my_turtle.py:            delta = 1.0*angle/steps
my_turtle.py:            for _ in range(steps):
my_turtle.py:                self._orient = self._orient.rotate(delta)
my_turtle.py:                self._update()
my_turtle.py:        self._orient = neworient
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def _newLine(self, usePos=True):
my_turtle.py:        """Closes current line item and starts a new one.
my_turtle.py:           Remark: if current line became too long, animation
my_turtle.py:           performance (via _drawline) slowed down considerably.
my_turtle.py:        """
my_turtle.py:        if len(self.currentLine) > 1:
my_turtle.py:            self.screen._drawline(self.currentLineItem, self.currentLine,
my_turtle.py:                                      self._pencolor, self._pensize)
my_turtle.py:            self.currentLineItem = self.screen._createline()
my_turtle.py:            self.items.append(self.currentLineItem)
my_turtle.py:        else:
my_turtle.py:            self.screen._drawline(self.currentLineItem, top=True)
my_turtle.py:        self.currentLine = []
my_turtle.py:        if usePos:
my_turtle.py:            self.currentLine = [self._position]
my_turtle.py:
my_turtle.py:    def filling(self):
my_turtle.py:        """Return fillstate (True if filling, False else).
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.begin_fill()
my_turtle.py:        >>> if turtle.filling():
my_turtle.py:        ...     turtle.pensize(5)
my_turtle.py:        ... else:
my_turtle.py:        ...     turtle.pensize(3)
my_turtle.py:        """
my_turtle.py:        return isinstance(self._fillpath, list)
my_turtle.py:
my_turtle.py:    def begin_fill(self):
my_turtle.py:        """Called just before drawing a shape to be filled.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.color("black", "red")
my_turtle.py:        >>> turtle.begin_fill()
my_turtle.py:        >>> turtle.circle(60)
my_turtle.py:        >>> turtle.end_fill()
my_turtle.py:        """
my_turtle.py:        if not self.filling():
my_turtle.py:            self._fillitem = self.screen._createpoly()
my_turtle.py:            self.items.append(self._fillitem)
my_turtle.py:        self._fillpath = [self._position]
my_turtle.py:        self._newLine()
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(("beginfill", self._fillitem))
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:
my_turtle.py:    def end_fill(self):
my_turtle.py:        """Fill the shape drawn after the call begin_fill().
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.color("black", "red")
my_turtle.py:        >>> turtle.begin_fill()
my_turtle.py:        >>> turtle.circle(60)
my_turtle.py:        >>> turtle.end_fill()
my_turtle.py:        """
my_turtle.py:        if self.filling():
my_turtle.py:            if len(self._fillpath) > 2:
my_turtle.py:                self.screen._drawpoly(self._fillitem, self._fillpath,
my_turtle.py:                                      fill=self._fillcolor)
my_turtle.py:                if self.undobuffer:
my_turtle.py:                    self.undobuffer.push(("dofill", self._fillitem))
my_turtle.py:            self._fillitem = self._fillpath = None
my_turtle.py:            self._update()
my_turtle.py:
my_turtle.py:    def dot(self, size=None, *color):
my_turtle.py:        """Draw a dot with diameter size, using color.
my_turtle.py:
my_turtle.py:        Optional arguments:
my_turtle.py:        size -- an integer >= 1 (if given)
my_turtle.py:        color -- a colorstring or a numeric color tuple
my_turtle.py:
my_turtle.py:        Draw a circular dot with diameter size, using color.
my_turtle.py:        If size is not given, the maximum of pensize+4 and 2*pensize is used.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.dot()
my_turtle.py:        >>> turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
my_turtle.py:        """
my_turtle.py:        if not color:
my_turtle.py:            if isinstance(size, (str, tuple)):
my_turtle.py:                color = self._colorstr(size)
my_turtle.py:                size = self._pensize + max(self._pensize, 4)
my_turtle.py:            else:
my_turtle.py:                color = self._pencolor
my_turtle.py:                if not size:
my_turtle.py:                    size = self._pensize + max(self._pensize, 4)
my_turtle.py:        else:
my_turtle.py:            if size is None:
my_turtle.py:                size = self._pensize + max(self._pensize, 4)
my_turtle.py:            color = self._colorstr(color)
my_turtle.py:        if hasattr(self.screen, "_dot"):
my_turtle.py:            item = self.screen._dot(self._position, size, color)
my_turtle.py:            self.items.append(item)
my_turtle.py:            if self.undobuffer:
my_turtle.py:                self.undobuffer.push(("dot", item))
my_turtle.py:        else:
my_turtle.py:            pen = self.pen()
my_turtle.py:            if self.undobuffer:
my_turtle.py:                self.undobuffer.push(["seq"])
my_turtle.py:                self.undobuffer.cumulate = True
my_turtle.py:            try:
my_turtle.py:                if self.resizemode() == 'auto':
my_turtle.py:                    self.ht()
my_turtle.py:                self.pendown()
my_turtle.py:                self.pensize(size)
my_turtle.py:                self.pencolor(color)
my_turtle.py:                self.forward(0)
my_turtle.py:            finally:
my_turtle.py:                self.pen(pen)
my_turtle.py:            if self.undobuffer:
my_turtle.py:                self.undobuffer.cumulate = False
my_turtle.py:
my_turtle.py:    def _write(self, txt, align, font):
my_turtle.py:        """Performs the writing for write()
my_turtle.py:        """
my_turtle.py:        item, end = self.screen._write(self._position, txt, align, font,
my_turtle.py:                                                          self._pencolor)
my_turtle.py:        self.items.append(item)
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(("wri", item))
my_turtle.py:        return end
my_turtle.py:
my_turtle.py:    def write(self, arg, move=False, align="left", font=("Arial", 8, "normal")):
my_turtle.py:        """Write text at the current turtle position.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        arg -- info, which is to be written to the TurtleScreen
my_turtle.py:        move (optional) -- True/False
my_turtle.py:        align (optional) -- one of the strings "left", "center" or right"
my_turtle.py:        font (optional) -- a triple (fontname, fontsize, fonttype)
my_turtle.py:
my_turtle.py:        Write text - the string representation of arg - at the current
my_turtle.py:        turtle position according to align ("left", "center" or right")
my_turtle.py:        and with the given font.
my_turtle.py:        If move is True, the pen is moved to the bottom-right corner
my_turtle.py:        of the text. By default, move is False.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.write('Home = ', True, align="center")
my_turtle.py:        >>> turtle.write((0,0), True)
my_turtle.py:        """
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.push(["seq"])
my_turtle.py:            self.undobuffer.cumulate = True
my_turtle.py:        end = self._write(str(arg), align.casefold(), font)
my_turtle.py:        if move:
my_turtle.py:            x, y = self.pos()
my_turtle.py:            self.setpos(end, y)
my_turtle.py:        if self.undobuffer:
my_turtle.py:            self.undobuffer.cumulate = False
my_turtle.py:
my_turtle.py:    def begin_poly(self):
my_turtle.py:        """Start recording the vertices of a polygon.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Start recording the vertices of a polygon. Current turtle position
my_turtle.py:        is first point of polygon.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.begin_poly()
my_turtle.py:        """
my_turtle.py:        self._poly = [self._position]
my_turtle.py:        self._creatingPoly = True
my_turtle.py:
my_turtle.py:    def end_poly(self):
my_turtle.py:        """Stop recording the vertices of a polygon.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Stop recording the vertices of a polygon. Current turtle position is
my_turtle.py:        last point of polygon. This will be connected with the first point.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.end_poly()
my_turtle.py:        """
my_turtle.py:        self._creatingPoly = False
my_turtle.py:
my_turtle.py:    def get_poly(self):
my_turtle.py:        """Return the lastly recorded polygon.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> p = turtle.get_poly()
my_turtle.py:        >>> turtle.register_shape("myFavouriteShape", p)
my_turtle.py:        """
my_turtle.py:        ## check if there is any poly?
my_turtle.py:        if self._poly is not None:
my_turtle.py:            return tuple(self._poly)
my_turtle.py:
my_turtle.py:    def getscreen(self):
my_turtle.py:        """Return the TurtleScreen object, the turtle is drawing  on.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Return the TurtleScreen object, the turtle is drawing  on.
my_turtle.py:        So TurtleScreen-methods can be called for that object.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> ts = turtle.getscreen()
my_turtle.py:        >>> ts
my_turtle.py:        <turtle.TurtleScreen object at 0x0106B770>
my_turtle.py:        >>> ts.bgcolor("pink")
my_turtle.py:        """
my_turtle.py:        return self.screen
my_turtle.py:
my_turtle.py:    def getturtle(self):
my_turtle.py:        """Return the Turtleobject itself.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        Only reasonable use: as a function to return the 'anonymous turtle':
my_turtle.py:
my_turtle.py:        Example:
my_turtle.py:        >>> pet = getturtle()
my_turtle.py:        >>> pet.fd(50)
my_turtle.py:        >>> pet
my_turtle.py:        <turtle.Turtle object at 0x0187D810>
my_turtle.py:        >>> turtles()
my_turtle.py:        [<turtle.Turtle object at 0x0187D810>]
my_turtle.py:        """
my_turtle.py:        return self
my_turtle.py:
my_turtle.py:    getpen = getturtle
my_turtle.py:
my_turtle.py:
my_turtle.py:    ################################################################
my_turtle.py:    ### screen oriented methods recurring to methods of TurtleScreen
my_turtle.py:    ################################################################
my_turtle.py:
my_turtle.py:    def _delay(self, delay=None):
my_turtle.py:        """Set delay value which determines speed of turtle animation.
my_turtle.py:        """
my_turtle.py:        return self.screen.delay(delay)
my_turtle.py:
my_turtle.py:    def onclick(self, fun, btn=1, add=None):
my_turtle.py:        """Bind fun to mouse-click event on this turtle on canvas.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun --  a function with two arguments, to which will be assigned
my_turtle.py:                the coordinates of the clicked point on the canvas.
my_turtle.py:        num --  number of the mouse-button defaults to 1 (left mouse button).
my_turtle.py:        add --  True or False. If True, new binding will be added, otherwise
my_turtle.py:                it will replace a former binding.
my_turtle.py:
my_turtle.py:        Example for the anonymous turtle, i. e. the procedural way:
my_turtle.py:
my_turtle.py:        >>> def turn(x, y):
my_turtle.py:        ...     left(360)
my_turtle.py:        ...
my_turtle.py:        >>> onclick(turn)  # Now clicking into the turtle will turn it.
my_turtle.py:        >>> onclick(None)  # event-binding will be removed
my_turtle.py:        """
my_turtle.py:        self.screen._onclick(self.turtle._item, fun, btn, add)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def onrelease(self, fun, btn=1, add=None):
my_turtle.py:        """Bind fun to mouse-button-release event on this turtle on canvas.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with two arguments, to which will be assigned
my_turtle.py:                the coordinates of the clicked point on the canvas.
my_turtle.py:        num --  number of the mouse-button defaults to 1 (left mouse button).
my_turtle.py:
my_turtle.py:        Example (for a MyTurtle instance named joe):
my_turtle.py:        >>> class MyTurtle(Turtle):
my_turtle.py:        ...     def glow(self,x,y):
my_turtle.py:        ...             self.fillcolor("red")
my_turtle.py:        ...     def unglow(self,x,y):
my_turtle.py:        ...             self.fillcolor("")
my_turtle.py:        ...
my_turtle.py:        >>> joe = MyTurtle()
my_turtle.py:        >>> joe.onclick(joe.glow)
my_turtle.py:        >>> joe.onrelease(joe.unglow)
my_turtle.py:
my_turtle.py:        Clicking on joe turns fillcolor red, unclicking turns it to
my_turtle.py:        transparent.
my_turtle.py:        """
my_turtle.py:        self.screen._onrelease(self.turtle._item, fun, btn, add)
my_turtle.py:        self._update()
my_turtle.py:
my_turtle.py:    def ondrag(self, fun, btn=1, add=None):
my_turtle.py:        """Bind fun to mouse-move event on this turtle on canvas.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        fun -- a function with two arguments, to which will be assigned
my_turtle.py:               the coordinates of the clicked point on the canvas.
my_turtle.py:        num -- number of the mouse-button defaults to 1 (left mouse button).
my_turtle.py:
my_turtle.py:        Every sequence of mouse-move-events on a turtle is preceded by a
my_turtle.py:        mouse-click event on that turtle.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> turtle.ondrag(turtle.goto)
my_turtle.py:
my_turtle.py:        Subsequently clicking and dragging a Turtle will move it
my_turtle.py:        across the screen thereby producing handdrawings (if pen is
my_turtle.py:        down).
my_turtle.py:        """
my_turtle.py:        self.screen._ondrag(self.turtle._item, fun, btn, add)
my_turtle.py:
my_turtle.py:
my_turtle.py:    def _undo(self, action, data):
my_turtle.py:        """Does the main part of the work for undo()
my_turtle.py:        """
my_turtle.py:        if self.undobuffer is None:
my_turtle.py:            return
my_turtle.py:        if action == "rot":
my_turtle.py:            angle, degPAU = data
my_turtle.py:            self._rotate(-angle*degPAU/self._degreesPerAU)
my_turtle.py:            dummy = self.undobuffer.pop()
my_turtle.py:        elif action == "stamp":
my_turtle.py:            stitem = data[0]
my_turtle.py:            self.clearstamp(stitem)
my_turtle.py:        elif action == "go":
my_turtle.py:            self._undogoto(data)
my_turtle.py:        elif action in ["wri", "dot"]:
my_turtle.py:            item = data[0]
my_turtle.py:            self.screen._delete(item)
my_turtle.py:            self.items.remove(item)
my_turtle.py:        elif action == "dofill":
my_turtle.py:            item = data[0]
my_turtle.py:            self.screen._drawpoly(item, ((0, 0),(0, 0),(0, 0)),
my_turtle.py:                                  fill="", outline="")
my_turtle.py:        elif action == "beginfill":
my_turtle.py:            item = data[0]
my_turtle.py:            self._fillitem = self._fillpath = None
my_turtle.py:            if item in self.items:
my_turtle.py:                self.screen._delete(item)
my_turtle.py:                self.items.remove(item)
my_turtle.py:        elif action == "pen":
my_turtle.py:            TPen.pen(self, data[0])
my_turtle.py:            self.undobuffer.pop()
my_turtle.py:
my_turtle.py:    def undo(self):
my_turtle.py:        """undo (repeatedly) the last turtle action.
my_turtle.py:
my_turtle.py:        No argument.
my_turtle.py:
my_turtle.py:        undo (repeatedly) the last turtle action.
my_turtle.py:        Number of available undo actions is determined by the size of
my_turtle.py:        the undobuffer.
my_turtle.py:
my_turtle.py:        Example (for a Turtle instance named turtle):
my_turtle.py:        >>> for i in range(4):
my_turtle.py:        ...     turtle.fd(50); turtle.lt(80)
my_turtle.py:        ...
my_turtle.py:        >>> for i in range(8):
my_turtle.py:        ...     turtle.undo()
my_turtle.py:        ...
my_turtle.py:        """
my_turtle.py:        if self.undobuffer is None:
my_turtle.py:            return
my_turtle.py:        item = self.undobuffer.pop()
my_turtle.py:        action = item[0]
my_turtle.py:        data = item[1:]
my_turtle.py:        if action == "seq":
my_turtle.py:            while data:
my_turtle.py:                item = data.pop()
my_turtle.py:                self._undo(item[0], item[1:])
my_turtle.py:        else:
my_turtle.py:            self._undo(action, data)
my_turtle.py:
my_turtle.py:    turtlesize = shapesize
my_turtle.py:
my_turtle.py:RawPen = RawTurtle
my_turtle.py:
my_turtle.py:###  Screen - Singleton  ########################
my_turtle.py:
my_turtle.py:def Screen():
my_turtle.py:    """Return the singleton screen object.
my_turtle.py:    If none exists at the moment, create a new one and return it,
my_turtle.py:    else return the existing one."""
my_turtle.py:    if Turtle._screen is None:
my_turtle.py:        Turtle._screen = _Screen()
my_turtle.py:    return Turtle._screen
my_turtle.py:
my_turtle.py:class _Screen(TurtleScreen):
my_turtle.py:
my_turtle.py:    _root = None
my_turtle.py:    _canvas = None
my_turtle.py:    _title = _CFG["title"]
my_turtle.py:
my_turtle.py:    def __init__(self):
my_turtle.py:        # XXX there is no need for this code to be conditional,
my_turtle.py:        # as there will be only a single _Screen instance, anyway
my_turtle.py:        # XXX actually, the turtle demo is injecting root window,
my_turtle.py:        # so perhaps the conditional creation of a root should be
my_turtle.py:        # preserved (perhaps by passing it as an optional parameter)
my_turtle.py:        if _Screen._root is None:
my_turtle.py:            _Screen._root = self._root = _Root()
my_turtle.py:            self._root.title(_Screen._title)
my_turtle.py:            self._root.ondestroy(self._destroy)
my_turtle.py:        if _Screen._canvas is None:
my_turtle.py:            width = _CFG["width"]
my_turtle.py:            height = _CFG["height"]
my_turtle.py:            canvwidth = _CFG["canvwidth"]
my_turtle.py:            canvheight = _CFG["canvheight"]
my_turtle.py:            leftright = _CFG["leftright"]
my_turtle.py:            topbottom = _CFG["topbottom"]
my_turtle.py:            self._root.setupcanvas(width, height, canvwidth, canvheight)
my_turtle.py:            _Screen._canvas = self._root._getcanvas()
my_turtle.py:            TurtleScreen.__init__(self, _Screen._canvas)
my_turtle.py:            self.setup(width, height, leftright, topbottom)
my_turtle.py:
my_turtle.py:    def setup(self, width=_CFG["width"], height=_CFG["height"],
my_turtle.py:              startx=_CFG["leftright"], starty=_CFG["topbottom"]):
my_turtle.py:        """ Set the size and position of the main window.
my_turtle.py:
my_turtle.py:        Arguments:
my_turtle.py:        width: as integer a size in pixels, as float a fraction of the screen.
my_turtle.py:          Default is 50% of screen.
my_turtle.py:        height: as integer the height in pixels, as float a fraction of the
my_turtle.py:          screen. Default is 75% of screen.
my_turtle.py:        startx: if positive, starting position in pixels from the left
my_turtle.py:          edge of the screen, if negative from the right edge
my_turtle.py:          Default, startx=None is to center window horizontally.
my_turtle.py:        starty: if positive, starting position in pixels from the top
my_turtle.py:          edge of the screen, if negative from the bottom edge
my_turtle.py:          Default, starty=None is to center window vertically.
my_turtle.py:
my_turtle.py:        Examples (for a Screen instance named screen):
my_turtle.py:        >>> screen.setup (width=200, height=200, startx=0, starty=0)
my_turtle.py:
my_turtle.py:        sets window to 200x200 pixels, in upper left of screen
my_turtle.py:
my_turtle.py:        >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)
my_turtle.py:
my_turtle.py:        sets window to 75% of screen by 50% of screen and centers
my_turtle.py:        """
my_turtle.py:        if not hasattr(self._root, "set_geometry"):
my_turtle.py:            return
my_turtle.py:        sw = self._root.win_width()
my_turtle.py:        sh = self._root.win_height()
my_turtle.py:        if isinstance(width, float) and 0 <= width <= 1:
my_turtle.py:            width = sw*width
my_turtle.py:        if startx is None:
my_turtle.py:            startx = (sw - width) / 2
my_turtle.py:        if isinstance(height, float) and 0 <= height <= 1:
my_turtle.py:            height = sh*height
my_turtle.py:        if starty is None:
my_turtle.py:            starty = (sh - height) / 2
my_turtle.py:        self._root.set_geometry(width, height, startx, starty)
my_turtle.py:        self.update()
my_turtle.py:
my_turtle.py:    def title(self, titlestring):
my_turtle.py:        """Set title of turtle-window
my_turtle.py:
my_turtle.py:        Argument:
my_turtle.py:        titlestring -- a string, to appear in the titlebar of the
my_turtle.py:                       turtle graphics window.
my_turtle.py:
my_turtle.py:        This is a method of Screen-class. Not available for TurtleScreen-
my_turtle.py:        objects.
my_turtle.py:
my_turtle.py:        Example (for a Screen instance named screen):
my_turtle.py:        >>> screen.title("Welcome to the turtle-zoo!")
my_turtle.py:        """
my_turtle.py:        if _Screen._root is not None:
my_turtle.py:            _Screen._root.title(titlestring)
my_turtle.py:        _Screen._title = titlestring
my_turtle.py:
my_turtle.py:    def _destroy(self):
my_turtle.py:        root = self._root
my_turtle.py:        if root is _Screen._root:
my_turtle.py:            Turtle._pen = None
my_turtle.py:            Turtle._screen = None
my_turtle.py:            _Screen._root = None
my_turtle.py:            _Screen._canvas = None
my_turtle.py:        TurtleScreen._RUNNING = False
my_turtle.py:        root.destroy()
my_turtle.py:
my_turtle.py:    def bye(self):
my_turtle.py:        """Shut the turtlegraphics window.
my_turtle.py:
my_turtle.py:        Example (for a TurtleScreen instance named screen):
my_turtle.py:        >>> screen.bye()
my_turtle.py:        """
my_turtle.py:        self._destroy()
my_turtle.py:
my_turtle.py:    def exitonclick(self):
my_turtle.py:        """Go into mainloop until the mouse is clicked.
my_turtle.py:
my_turtle.py:        No arguments.
my_turtle.py:
my_turtle.py:        Bind bye() method to mouseclick on TurtleScreen.
my_turtle.py:        If "using_IDLE" - value in configuration dictionary is False
my_turtle.py:        (default value), enter mainloop.
my_turtle.py:        If IDLE with -n switch (no subprocess) is used, this value should be
my_turtle.py:        set to True in turtle.cfg. In this case IDLE's mainloop
my_turtle.py:        is active also for the client script.
my_turtle.py:
my_turtle.py:        This is a method of the Screen-class and not available for
my_turtle.py:        TurtleScreen instances.
my_turtle.py:
my_turtle.py:        Example (for a Screen instance named screen):
my_turtle.py:        >>> screen.exitonclick()
my_turtle.py:
my_turtle.py:        """
my_turtle.py:        def exitGracefully(x, y):
my_turtle.py:            """Screen.bye() with two dummy-parameters"""
my_turtle.py:            self.bye()
my_turtle.py:        self.onclick(exitGracefully)
my_turtle.py:        if _CFG["using_IDLE"]:
my_turtle.py:            return
my_turtle.py:        try:
my_turtle.py:            mainloop()
my_turtle.py:        except AttributeError:
my_turtle.py:            exit(0)
my_turtle.py:
my_turtle.py:class Turtle(RawTurtle):
my_turtle.py:    """RawTurtle auto-creating (scrolled) canvas.
my_turtle.py:
my_turtle.py:    When a Turtle object is created or a function derived from some
my_turtle.py:    Turtle method is called a TurtleScreen object is automatically created.
my_turtle.py:    """
my_turtle.py:    _pen = None
my_turtle.py:    _screen = None
my_turtle.py:
my_turtle.py:    def __init__(self,
my_turtle.py:                 shape=_CFG["shape"],
my_turtle.py:                 undobuffersize=_CFG["undobuffersize"],
my_turtle.py:                 visible=_CFG["visible"],
my_turtle.py:                 name=None):
my_turtle.py:        if not(name is None):
my_turtle.py:            self.name = name
my_turtle.py:        if Turtle._screen is None:
my_turtle.py:            Turtle._screen = Screen()
my_turtle.py:        RawTurtle.__init__(self, Turtle._screen,
my_turtle.py:                           shape=shape,
my_turtle.py:                           undobuffersize=undobuffersize,
my_turtle.py:                           visible=visible)
my_turtle.py:
my_turtle.py:Pen = Turtle
my_turtle.py:
my_turtle.py:def write_docstringdict(filename="turtle_docstringdict"):
my_turtle.py:    """Create and write docstring-dictionary to file.
my_turtle.py:
my_turtle.py:    Optional argument:
my_turtle.py:    filename -- a string, used as filename
my_turtle.py:                default value is turtle_docstringdict
my_turtle.py:
my_turtle.py:    Has to be called explicitly, (not used by the turtle-graphics classes)
my_turtle.py:    The docstring dictionary will be written to the Python script <filname>.py
my_turtle.py:    It is intended to serve as a template for translation of the docstrings
my_turtle.py:    into different languages.
my_turtle.py:    """
my_turtle.py:    docsdict = {}
my_turtle.py:
my_turtle.py:    for methodname in _tg_screen_functions:
my_turtle.py:        key = "_Screen."+methodname
my_turtle.py:        docsdict[key] = eval(key).__doc__
my_turtle.py:    for methodname in _tg_turtle_functions:
my_turtle.py:        key = "Turtle."+methodname
my_turtle.py:        docsdict[key] = eval(key).__doc__
my_turtle.py:
my_turtle.py:    with open("%s.py" % filename,"w") as f:
my_turtle.py:        keys = sorted([x for x in docsdict.keys()
my_turtle.py:                            if x.split('.')[1] not in _alias_list])
my_turtle.py:        f.write('docsdict = {\n\n')
my_turtle.py:        for key in keys[:-1]:
my_turtle.py:            f.write('%s :\n' % repr(key))
my_turtle.py:            f.write('        """%s\n""",\n\n' % docsdict[key])
my_turtle.py:        key = keys[-1]
my_turtle.py:        f.write('%s :\n' % repr(key))
my_turtle.py:        f.write('        """%s\n"""\n\n' % docsdict[key])
my_turtle.py:        f.write("}\n")
my_turtle.py:        f.close()
my_turtle.py:
my_turtle.py:def read_docstrings(lang):
my_turtle.py:    """Read in docstrings from lang-specific docstring dictionary.
my_turtle.py:
my_turtle.py:    Transfer docstrings, translated to lang, from a dictionary-file
my_turtle.py:    to the methods of classes Screen and Turtle and - in revised form -
my_turtle.py:    to the corresponding functions.
my_turtle.py:    """
my_turtle.py:    modname = "turtle_docstringdict_%(language)s" % {'language':lang.casefold()}
my_turtle.py:    module = __import__(modname)
my_turtle.py:    docsdict = module.docsdict
my_turtle.py:    for key in docsdict:
my_turtle.py:        try:
my_turtle.py:#            eval(key).im_func.__doc__ = docsdict[key]
my_turtle.py:            eval(key).__doc__ = docsdict[key]
my_turtle.py:        except:
my_turtle.py:            print("Bad docstring-entry: %s" % key)
my_turtle.py:
my_turtle.py:_LANGUAGE = _CFG["language"]
my_turtle.py:
my_turtle.py:try:
my_turtle.py:    if _LANGUAGE != "english":
my_turtle.py:        read_docstrings(_LANGUAGE)
my_turtle.py:except ImportError:
my_turtle.py:    print("Cannot find docsdict for", _LANGUAGE)
my_turtle.py:except:
my_turtle.py:    print ("Unknown Error when trying to import %s-docstring-dictionary" %
my_turtle.py:                                                                  _LANGUAGE)
my_turtle.py:
my_turtle.py:
my_turtle.py:def getmethparlist(ob):
my_turtle.py:    """Get strings describing the arguments for the given object
my_turtle.py:
my_turtle.py:    Returns a pair of strings representing function parameter lists
my_turtle.py:    including parenthesis.  The first string is suitable for use in
my_turtle.py:    function definition and the second is suitable for use in function
my_turtle.py:    call.  The "self" parameter is not included.
my_turtle.py:    """
my_turtle.py:    defText = callText = ""
my_turtle.py:    # bit of a hack for methods - turn it into a function
my_turtle.py:    # but we drop the "self" param.
my_turtle.py:    # Try and build one for Python defined functions
my_turtle.py:    args, varargs, varkw = inspect.getargs(ob.__code__)
my_turtle.py:    items2 = args[1:]
my_turtle.py:    realArgs = args[1:]
my_turtle.py:    defaults = ob.__defaults__ or []
my_turtle.py:    defaults = ["=%r" % (value,) for value in defaults]
my_turtle.py:    defaults = [""] * (len(realArgs)-len(defaults)) + defaults
my_turtle.py:    items1 = [arg + dflt for arg, dflt in zip(realArgs, defaults)]
my_turtle.py:    if varargs is not None:
my_turtle.py:        items1.append("*" + varargs)
my_turtle.py:        items2.append("*" + varargs)
my_turtle.py:    if varkw is not None:
my_turtle.py:        items1.append("**" + varkw)
my_turtle.py:        items2.append("**" + varkw)
my_turtle.py:    defText = ", ".join(items1)
my_turtle.py:    defText = "(%s)" % defText
my_turtle.py:    callText = ", ".join(items2)
my_turtle.py:    callText = "(%s)" % callText
my_turtle.py:    return defText, callText
my_turtle.py:
my_turtle.py:def _turtle_docrevise(docstr):
my_turtle.py:    """To reduce docstrings from RawTurtle class for functions
my_turtle.py:    """
my_turtle.py:    import re
my_turtle.py:    if docstr is None:
my_turtle.py:        return None
my_turtle.py:    turtlename = _CFG["exampleturtle"]
my_turtle.py:    newdocstr = docstr.replace("%s." % turtlename,"")
my_turtle.py:    parexp = re.compile(r' \(.+ %s\):' % turtlename)
my_turtle.py:    newdocstr = parexp.sub(":", newdocstr)
my_turtle.py:    return newdocstr
my_turtle.py:
my_turtle.py:def _screen_docrevise(docstr):
my_turtle.py:    """To reduce docstrings from TurtleScreen class for functions
my_turtle.py:    """
my_turtle.py:    import re
my_turtle.py:    if docstr is None:
my_turtle.py:        return None
my_turtle.py:    screenname = _CFG["examplescreen"]
my_turtle.py:    newdocstr = docstr.replace("%s." % screenname,"")
my_turtle.py:    parexp = re.compile(r' \(.+ %s\):' % screenname)
my_turtle.py:    newdocstr = parexp.sub(":", newdocstr)
my_turtle.py:    return newdocstr
my_turtle.py:
my_turtle.py:## The following mechanism makes all methods of RawTurtle and Turtle available
my_turtle.py:## as functions. So we can enhance, change, add, delete methods to these
my_turtle.py:## classes and do not need to change anything here.
my_turtle.py:
my_turtle.py:__func_body = """\
my_turtle.py:def {name}{paramslist}:
my_turtle.py:    if {obj} is None:
my_turtle.py:        if not TurtleScreen._RUNNING:
my_turtle.py:            TurtleScreen._RUNNING = True
my_turtle.py:            raise Terminator
my_turtle.py:        {obj} = {init}
my_turtle.py:    try:
my_turtle.py:        return {obj}.{name}{argslist}
my_turtle.py:    except TK.TclError:
my_turtle.py:        if not TurtleScreen._RUNNING:
my_turtle.py:            TurtleScreen._RUNNING = True
my_turtle.py:            raise Terminator
my_turtle.py:        raise
my_turtle.py:"""
my_turtle.py:
my_turtle.py:def _make_global_funcs(functions, cls, obj, init, docrevise):
my_turtle.py:    for methodname in functions:
my_turtle.py:        method = getattr(cls, methodname)
my_turtle.py:        pl1, pl2 = getmethparlist(method)
my_turtle.py:        if pl1 == "":
my_turtle.py:            print(">>>>>>", pl1, pl2)
my_turtle.py:            continue
my_turtle.py:        defstr = __func_body.format(obj=obj, init=init, name=methodname,
my_turtle.py:                                    paramslist=pl1, argslist=pl2)
my_turtle.py:        exec(defstr, globals())
my_turtle.py:        globals()[methodname].__doc__ = docrevise(method.__doc__)
my_turtle.py:
my_turtle.py:_make_global_funcs(_tg_screen_functions, _Screen,
my_turtle.py:                   'Turtle._screen', 'Screen()', _screen_docrevise)
my_turtle.py:_make_global_funcs(_tg_turtle_functions, Turtle,
my_turtle.py:                   'Turtle._pen', 'Turtle()', _turtle_docrevise)
my_turtle.py:
my_turtle.py:
my_turtle.py:done = mainloop
my_turtle.py:
my_turtle.py:if __name__ == "__main__":
my_turtle.py:    def switchpen():
my_turtle.py:        if isdown():
my_turtle.py:            pu()
my_turtle.py:        else:
my_turtle.py:            pd()
my_turtle.py:
my_turtle.py:    def demo1():
my_turtle.py:        """Demo of old turtle.py - module"""
my_turtle.py:        reset()
my_turtle.py:        tracer(True)
my_turtle.py:        up()
my_turtle.py:        backward(100)
my_turtle.py:        down()
my_turtle.py:        # draw 3 squares; the last filled
my_turtle.py:        width(3)
my_turtle.py:        for i in range(3):
my_turtle.py:            if i == 2:
my_turtle.py:                begin_fill()
my_turtle.py:            for _ in range(4):
my_turtle.py:                forward(20)
my_turtle.py:                left(90)
my_turtle.py:            if i == 2:
my_turtle.py:                color("maroon")
my_turtle.py:                end_fill()
my_turtle.py:            up()
my_turtle.py:            forward(30)
my_turtle.py:            down()
my_turtle.py:        width(1)
my_turtle.py:        color("black")
my_turtle.py:        # move out of the way
my_turtle.py:        tracer(False)
my_turtle.py:        up()
my_turtle.py:        right(90)
my_turtle.py:        forward(100)
my_turtle.py:        right(90)
my_turtle.py:        forward(100)
my_turtle.py:        right(180)
my_turtle.py:        down()
my_turtle.py:        # some text
my_turtle.py:        write("startstart", 1)
my_turtle.py:        write("start", 1)
my_turtle.py:        color("red")
my_turtle.py:        # staircase
my_turtle.py:        for i in range(5):
my_turtle.py:            forward(20)
my_turtle.py:            left(90)
my_turtle.py:            forward(20)
my_turtle.py:            right(90)
my_turtle.py:        # filled staircase
my_turtle.py:        tracer(True)
my_turtle.py:        begin_fill()
my_turtle.py:        for i in range(5):
my_turtle.py:            forward(20)
my_turtle.py:            left(90)
my_turtle.py:            forward(20)
my_turtle.py:            right(90)
my_turtle.py:        end_fill()
my_turtle.py:        # more text
my_turtle.py:
my_turtle.py:    def demo2():
my_turtle.py:        """Demo of some new features."""
my_turtle.py:        speed(1)
my_turtle.py:        st()
my_turtle.py:        pensize(3)
my_turtle.py:        setheading(towards(0, 0))
my_turtle.py:        radius = distance(0, 0)/2.0
my_turtle.py:        rt(90)
my_turtle.py:        for _ in range(18):
my_turtle.py:            switchpen()
my_turtle.py:            circle(radius, 10)
my_turtle.py:        write("wait a moment...")
my_turtle.py:        while undobufferentries():
my_turtle.py:            undo()
my_turtle.py:        reset()
my_turtle.py:        lt(90)
my_turtle.py:        colormode(255)
my_turtle.py:        laenge = 10
my_turtle.py:        pencolor("green")
my_turtle.py:        pensize(3)
my_turtle.py:        lt(180)
my_turtle.py:        for i in range(-2, 16):
my_turtle.py:            if i > 0:
my_turtle.py:                begin_fill()
my_turtle.py:                fillcolor(255-15*i, 0, 15*i)
my_turtle.py:            for _ in range(3):
my_turtle.py:                fd(laenge)
my_turtle.py:                lt(120)
my_turtle.py:            end_fill()
my_turtle.py:            laenge += 10
my_turtle.py:            lt(15)
my_turtle.py:            speed((speed()+1)%12)
my_turtle.py:        #end_fill()
my_turtle.py:
my_turtle.py:        lt(120)
my_turtle.py:        pu()
my_turtle.py:        fd(70)
my_turtle.py:        rt(30)
my_turtle.py:        pd()
my_turtle.py:        color("red","yellow")
my_turtle.py:        speed(0)
my_turtle.py:        begin_fill()
my_turtle.py:        for _ in range(4):
my_turtle.py:            circle(50, 90)
my_turtle.py:            rt(90)
my_turtle.py:            fd(30)
my_turtle.py:            rt(90)
my_turtle.py:        end_fill()
my_turtle.py:        lt(90)
my_turtle.py:        pu()
my_turtle.py:        fd(30)
my_turtle.py:        pd()
my_turtle.py:        shape("turtle")
my_turtle.py:
my_turtle.py:        tri = getturtle()
my_turtle.py:        tri.resizemode("auto")
my_turtle.py:        turtle = Turtle()
my_turtle.py:        turtle.resizemode("auto")
my_turtle.py:        turtle.shape("turtle")
my_turtle.py:        turtle.reset()
my_turtle.py:        turtle.left(90)
my_turtle.py:        turtle.speed(0)
my_turtle.py:        turtle.up()
my_turtle.py:        turtle.goto(280, 40)
my_turtle.py:        turtle.lt(30)
my_turtle.py:        turtle.down()
my_turtle.py:        turtle.speed(6)
my_turtle.py:        turtle.color("blue","orange")
my_turtle.py:        turtle.pensize(2)
my_turtle.py:        tri.speed(6)
my_turtle.py:        setheading(towards(turtle))
my_turtle.py:        count = 1
my_turtle.py:        while tri.distance(turtle) > 4:
my_turtle.py:            turtle.fd(3.5)
my_turtle.py:            turtle.lt(0.6)
my_turtle.py:            tri.setheading(tri.towards(turtle))
my_turtle.py:            tri.fd(4)
my_turtle.py:            if count % 20 == 0:
my_turtle.py:                turtle.stamp()
my_turtle.py:                tri.stamp()
my_turtle.py:                switchpen()
my_turtle.py:            count += 1
my_turtle.py:        tri.write("CAUGHT! ", font=("Arial", 16, "bold"), align="right")
my_turtle.py:        tri.pencolor("black")
my_turtle.py:        tri.pencolor("red")
my_turtle.py:
my_turtle.py:        def baba(xdummy, ydummy):
my_turtle.py:            clearscreen()
my_turtle.py:            bye()
my_turtle.py:
my_turtle.py:        time.sleep(2)
my_turtle.py:
my_turtle.py:        while undobufferentries():
my_turtle.py:            tri.undo()
my_turtle.py:            turtle.undo()
my_turtle.py:        tri.fd(50)
my_turtle.py:        tri.write("  Click me!", font = ("Courier", 12, "bold") )
my_turtle.py:        tri.onclick(baba, 1)
my_turtle.py:
my_turtle.py:    demo1()
my_turtle.py:    demo2()
my_turtle.py:    exitonclick()
Nmap.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Nmap.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Nmap.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Nmap.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Nmap.py:#! C:\Users\MichaelLFarwell\AppData\Local\Programs\Python\Python35-32\python.exe
Nmap.py:
Nmap.py:import subprocess as sp
Nmap.py:import webbrowser, os, methods
Nmap.py:from number_funct import *
Nmap.py:
Nmap.py:##proc = sp.Popen('cmd.exe', stdin = sp.PIPE, stdout = sp.PIPE)
Nmap.py:
Nmap.py:sp.check_output("dir C:\Windows\winsxs\wow64_microsoft-windows-commandprompt_31bf3856ad364e35_6.1.7601.17514_none_f387767e655cd5ab", shell=True).decode()
Nmap.py:
Nmap.py:##print (sp.check_output(['nmap', '--help'], shell=True).rstrip().decode())
Nmap.py:##import os;
Nmap.py:##os.system("C:\\Temp\\a b c\\Notepad.exe");
Nmap.py:##raw_input();
Nmap.py:
Nmap.py:##print ("TEST")
Nmap.py:
Nmap.py:def filter_for_int(s):
Nmap.py:    if is_number(s):
Nmap.py:        return s
Nmap.py:
Nmap.py:
Nmap.py:def ask_for_input():
Nmap.py:    option = input('What would you like to do? \n [R]un Zenmap \n [N]map scan \n [I]P config \n [D]efault Gateway \n [S]how available options \n [H]elp \n [C]lear \n [E]nd \n').casefold()
Nmap.py:    option_list = ("s", "h", "e", "r", "i", "d", "c", "n",)
Nmap.py:    while not(option in option_list):
Nmap.py:        print (option + " is not a valid answer \n")
Nmap.py:        option = input('What would you like to do? \n [R]un Zenmap \n [N]map scan \n [I]P config \n [D]efault Gateway \n [S]how available options \n [H]elp \n [C]lear \n [E]nd \n').casefold()
Nmap.py:    if option == 's':
Nmap.py:            ##print ("debug")
Nmap.py:            print (sp.check_output(['nmap', '--help'], shell=True).rstrip().decode())
Nmap.py:            ask_for_input()
Nmap.py:    elif option == 'h':
Nmap.py:            help_type = input('Which page? \n [W]iki page \n [N]map website \n [E]xit \n').casefold()
Nmap.py:            while not(help_type == "w") and not(help_type == "n") and not(help_type == "e"):
Nmap.py:                print("%s is not an answer \n" % help_type)
Nmap.py:                help_type = input('Which page? \n [W]iki page \n [N]map website \n [E]xit \n').casefold()
Nmap.py:            if help_type == "n":
Nmap.py:                webbrowser.open("https://nmap.org/book/man-briefoptions.html")
Nmap.py:                ask_for_input()
Nmap.py:            elif help_type == "w":
Nmap.py:                webbrowser.open("https://en.wikipedia.org/wiki/Nmap")
Nmap.py:                ask_for_input()
Nmap.py:            else:
Nmap.py:                ask_for_input()
Nmap.py:    elif option == 'r':
Nmap.py:        sp.call("P:\\Nmap\\zenmap.exe")
Nmap.py:        ask_for_input()
Nmap.py:    elif option == 'i':
Nmap.py:        print (sp.check_output(['ipconfig', '/allcompartments', '/all'], shell=True).rstrip().decode(), " \n")
Nmap.py:        ask_for_input()
Nmap.py:    elif option == 'd':
Nmap.py:        ipconfig = str(sp.check_output(['ipconfig', '/all'], shell=True).rstrip().decode())
Nmap.py:        #   Default Gateway . . . . . . . . . : x.x.x.x
Nmap.py:        dg_string = "Default Gateway . . . . . . . . . :"
Nmap.py:        for index, i in enumerate(ipconfig):
Nmap.py:            if ipconfig[index:index+35] == dg_string:
Nmap.py:                default_gateway = ipconfig[index+35:index+50].strip()
Nmap.py:        print ("Default Gateway: \n", default_gateway + "\n")
Nmap.py:        ask_for_input()
Nmap.py:        ##print ("#LEN", len(dg_string)) >>> 35
Nmap.py:    elif option == 'c':
Nmap.py:        methods.clearscreen()
Nmap.py:        ask_for_input()
Nmap.py:    elif option == "n":
Nmap.py:        is_args = input("Any arguments? \n [Y] or [N] \n")
Nmap.py:        while not(is_args == 'y' or is_args == 'n'):
Nmap.py:            print (is_args + " is not an answer, please answer with 'y' or 'n' \n")
Nmap.py:            is_args = input("Any arguments? \n [Y] or [N] \n")
Nmap.py:        args = input("Arguments (seperated by comma): \n")
Nmap.py:        valid_chars = (" ", "-", ",", "?",)
Nmap.py:        for index, i in enumerate(args):
Nmap.py:            if not(i in valid_chars or methods.is_alphanumeric(i)):
Nmap.py:                print (i + " is not a valid character")
Nmap.py:                args = input("Arguments (separated by comma): \n")
Nmap.py:        arg_list = []
Nmap.py:        args = ''.join(args)
Nmap.py:        args = args.split(sep=',')
Nmap.py:        for index, i in enumerate(args):
Nmap.py:            if (i == " ") and (args[index+1] == " "):
Nmap.py:                print (i)
Nmap.py:        #while ('' in args):
Nmap.py:            #args.remove('')
Nmap.py:        print ("#ARGS", args)
Nmap.py:        for index, i in enumerate(args):
Nmap.py:            if not(i[0] == "-"):
Nmap.py:                args[index] = "-" + i
Nmap.py:        try:
Nmap.py:            sp.check_output(['nmap', [i for i in args]], shell=True).rstrip().decode()
Nmap.py:            good_args = True
Nmap.py:        except:
Nmap.py:            ValueError
Nmap.py:            good_args = False
Nmap.py:        if good_args:
Nmap.py:            ip = input("Please give an ip: \n")
Nmap.py:            print (sp.check_output(['nmap', [i for i in args], ip], shell=True).rstrip().decode())
Nmap.py:            ask_for_input()
Nmap.py:        else:
Nmap.py:            print ("Invalid Arguments \n")
Nmap.py:            ask_for_input()
Nmap.py:    elif option == 'e':
Nmap.py:            confirm = input("Are you sure? \n [Y]es or [N]o \n").casefold()
Nmap.py:            while not(confirm == 'y' or confirm == 'n'):
Nmap.py:                print (confirm + " is not an option, please answer with 'y' or 'n'")
Nmap.py:                confirm = input("Are you sure? \n [Y]es or [N]o \n").casefold()
Nmap.py:            else:
Nmap.py:                if confirm == 'y':
Nmap.py:                    exit
Nmap.py:                else:
Nmap.py:                    ask_for_input()
Nmap.py:
Nmap.py:
Nmap.py:ask_for_input()
Nmap.py:
number_funct.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
number_funct.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
number_funct.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
number_funct.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
number_funct.py:from hex_values import *
number_funct.py:from collections import OrderedDict
number_funct.py:def is_number(x):
number_funct.py:    try:
number_funct.py:        int(x)
number_funct.py:        return True
number_funct.py:    except ValueError:
number_funct.py:        return False
number_funct.py:##print (is_number("3.02"))
number_funct.py:##print (is_number("3"))
number_funct.py:##print (is_number(3))
number_funct.py:def is_float(x):
number_funct.py:    try:
number_funct.py:        float(x)
number_funct.py:        return True
number_funct.py:    except ValueError:
number_funct.py:        return False
number_funct.py:def list_to_bin(l):
number_funct.py:    bin_list = []
number_funct.py:    ##print ("#l", l)
number_funct.py:    for n in l:
number_funct.py:        ##print ("#n", n, "\n", "#l", l)
number_funct.py:        n = int(n)
number_funct.py:        x = bin(n)
number_funct.py:        bin_list += [x[2:].zfill(8)]
number_funct.py:    print ("#bin_list", bin_list, "\n")
number_funct.py:    bin_string = " ".join(bin_list)
number_funct.py:    return bin_string
number_funct.py:#t = ["3", "4", "3", "1"]
number_funct.py:
number_funct.py:def left_shift(times, l):
number_funct.py:    bin_list = []
number_funct.py:    for n in l:
number_funct.py:        n = int(n)
number_funct.py:        x = bin(n << times)
number_funct.py:        bin_list += [x[2:].zfill(8)]
number_funct.py:    bin_string = " ".join(bin_list)
number_funct.py:    return bin_string
number_funct.py:##print (left_shift(2, t))
number_funct.py:def right_shift(times, l):
number_funct.py:    bin_list = []
number_funct.py:    for n in l:
number_funct.py:        n = int(n)
number_funct.py:        x = bin(n >> times)
number_funct.py:        bin_list += [x[2:].zfill(8)]
number_funct.py:    bin_string = " ".join(bin_list)
number_funct.py:def mix_up(l):
number_funct.py:    bin_list = []
number_funct.py:    for n in l:
number_funct.py:        n = int(n)
number_funct.py:        x = 0b10001110
number_funct.py:        y = 0b00010001 + x - 0b101
number_funct.py:        mask = y | x
number_funct.py:        z = n ^ mask
number_funct.py:        a = (z | n & mask ^ y)
number_funct.py:        a = bin(a)
number_funct.py:        bin_list += [a[2:].zfill(8)]
number_funct.py:    return (" ".join(bin_list))
number_funct.py:
number_funct.py:def dec_to_hex(x):
number_funct.py:    hex_values = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f")
number_funct.py:    L = []
number_funct.py:    op_list = []
number_funct.py:    op_num = 0
number_funct.py:    mod16 = False
number_funct.py:    for index, i in enumerate(str(x)):
number_funct.py:        L.append(i)
number_funct.py:    for index, i in enumerate(op_list):
number_funct.py:        while (not(mod16)):
number_funct.py:           op_num += L[index::]
number_funct.py:           op_list.remove(op_list[index])
number_funct.py:           print ("#op_num:", op_num)
number_funct.py:           if op_num % 16 == 0:
number_funct.py:                return op_list
number_funct.py:            
number_funct.py:    ##print (op_list)
pythag.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
pythag.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
pythag.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
pythag.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
pythag.py:from number_funct import *
pythag.py:from math import *
pythag.py:
pythag.py:print("Please give two side lengths. (Must be for right triangle")
pythag.py:side1 = input("Side 1 =    ")
pythag.py:side2 = input("Side 2 =    ")
pythag.py:if (is_float(side1) and is_float(side2)):
pythag.py:    side1 = float(side1)
pythag.py:    side2 = float(side2)
pythag.py:    side3 = sqrt((side1*side1) + (side2*side2))
pythag.py:    print ("Missing side length = %s" % side3)
pythag.py:else:
pythag.py:    print ("Please only give numbers")
RPS_Game.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
RPS_Game.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
RPS_Game.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
RPS_Game.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
RPS_Game.py:import random
RPS_Game.py:import sys
RPS_Game.py:import time
RPS_Game.py:import turtle
RPS_Game.py:
RPS_Game.py:screen = turtle.Screen()
RPS_Game.py:
RPS_Game.py:pic_Quit = turtle.Shape("image", data="P:\Python\Resources\Q_btn.gif")
RPS_Game.py:pic_Rock = turtle.Shape("image", data="P:\Python\Resources\Rock.gif")
RPS_Game.py:pic_Paper = turtle.Shape("image", data="P:\Python\Resources\Paper.gif")
RPS_Game.py:pic_Scissors = turtle.Shape("image", data="P:\Python\Resources\Scissors.gif")
RPS_Game.py:screen.register_shape("pic_Quit", shape=pic_Quit)
RPS_Game.py:Q_btn = turtle.Turtle()
RPS_Game.py:Q_btn.shape(name="pic_Quit")
RPS_Game.py:
RPS_Game.py:Q_btn.resizemode("user")
RPS_Game.py:Q_btn.shapesize(0.5, 0.5, 0.5)
RPS_Game.py:Q_btn.shapesize(outline=1)
RPS_Game.py:
signature.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
signature.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
signature.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
signature.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
signature.py:signature = "01001101 01101001 01100011 01101000 01100001 01100101 01101100 00100000 01000011 01101111 01101111 01110000 01100101 01110010"
signature.py:
Sort_Algorithm.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Sort_Algorithm.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Sort_Algorithm.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Sort_Algorithm.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
Sort_Algorithm.py:from collections import OrderedDict
Sort_Algorithm.py:import my_turtle as turtle
Sort_Algorithm.py:import math, sys, time, random
Sort_Algorithm.py:from number_funct import *
Sort_Algorithm.py:
Sort_Algorithm.py:
Sort_Algorithm.py:
Sort_Algorithm.py:
Sort_Algorithm.py:def mk_graph(values, t):
Sort_Algorithm.py:    t.pensize(3)
Sort_Algorithm.py:    t.pu()
Sort_Algorithm.py:    last_pos = (-300.0, -350)
Sort_Algorithm.py:    next_pos = ()
Sort_Algorithm.py:    for i in values:
Sort_Algorithm.py:##        print (t.pos())
Sort_Algorithm.py:        if is_number(i):
Sort_Algorithm.py:            if t.pos() == last_pos:
Sort_Algorithm.py:                t.goto(next_pos)
Sort_Algorithm.py:            else:
Sort_Algorithm.py:                t.goto(last_pos)
Sort_Algorithm.py:            last_pos = t.pos()
Sort_Algorithm.py:            next_pos = (last_pos[0] + 10, last_pos[1])
Sort_Algorithm.py:##            t.stamp()
Sort_Algorithm.py:            t.pd()
Sort_Algorithm.py:            print (i)
Sort_Algorithm.py:            t.setheading(90)
Sort_Algorithm.py:            t.fd(i * 6)
Sort_Algorithm.py:            t.bk(i * 6)
Sort_Algorithm.py:            t.pu()
Sort_Algorithm.py:    print ("\n")
Sort_Algorithm.py:
Sort_Algorithm.py:
Sort_Algorithm.py:def mk_pairs(values):
Sort_Algorithm.py:    pairs = []
Sort_Algorithm.py:    len_values = len(values)
Sort_Algorithm.py:    is_even = False
Sort_Algorithm.py:    #EVEN:
Sort_Algorithm.py:    if len_values % 2 == 0:
Sort_Algorithm.py:        is_even = True
Sort_Algorithm.py:        print (len(values), "# of values \n")
Sort_Algorithm.py:        for index, i in enumerate(values):
Sort_Algorithm.py:            if index % 2 == 0:
Sort_Algorithm.py:                pairs.append((i, values[index + 1]))
Sort_Algorithm.py:    #ODD:
Sort_Algorithm.py:    else:
Sort_Algorithm.py:        print (len(values), "# of values \n")
Sort_Algorithm.py:        """BREAK:"""
Sort_Algorithm.py:        for index, i in enumerate(values):
Sort_Algorithm.py:            ##print (index, i)
Sort_Algorithm.py:            if not(index == (len(values) - 1)):
Sort_Algorithm.py:                #if not(last value in values):
Sort_Algorithm.py:                if (index % 2 == 0):
Sort_Algorithm.py:                    pairs.append((i, values[index + 1]))
Sort_Algorithm.py:            else:
Sort_Algorithm.py:                pairs.append(i)
Sort_Algorithm.py:                
Sort_Algorithm.py:    return pairs, is_even
Sort_Algorithm.py:
Sort_Algorithm.py:def srt_pairs(values, is_even, t):
Sort_Algorithm.py:    print ("#VALUES: \n %s" % values)
Sort_Algorithm.py:    for i
Sort_Algorithm.py:    
Sort_Algorithm.py:
Sort_Algorithm.py:screen = turtle.Screen()
Sort_Algorithm.py:my_turtle = turtle.Turtle(name="main")
Sort_Algorithm.py:
Sort_Algorithm.py:
Sort_Algorithm.py:test_values = [3, 2, 5, 1, 7, 10, 20, 3, 16, 50, 100, 32, 40, 11, 13, 2, 1, 3, 5, 78, 40]#, 42] #42 == even
Sort_Algorithm.py:#mk_graph(test_values, my_turtle)
Sort_Algorithm.py:pairs, is_even = mk_pairs(test_values)#, my_turtle)
Sort_Algorithm.py:
Sort_Algorithm.py:srtd_pairs = srt_pairs(test_values, is_even, my_turtle)
test_input_for_hex.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
test_input_for_hex.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
test_input_for_hex.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
test_input_for_hex.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
test_input_for_hex.py:﻿from hex_values import *
test_input_for_hex.py:from number_funct import *
test_input_for_hex.py:from methods import *
test_input_for_hex.py:from signature import *
test_input_for_hex.py:in_text = input("Please give a hex value:    ")
test_input_for_hex.py:
test_input_for_hex.py:if in_text == "signature":
test_input_for_hex.py:    print (signature)
test_input_for_hex.py:    exit()
test_input_for_hex.py:in_text_ns = list(filter(lambda x: x != " ", in_text))
test_input_for_hex.py:##print (in_text_ns)
test_input_for_hex.py:
test_input_for_hex.py:in_text = ""
test_input_for_hex.py:for i in in_text_ns:
test_input_for_hex.py:    in_text += i
test_input_for_hex.py:print (in_text)
test_input_for_hex.py:
test_input_for_hex.py:in_hex = [i for i in in_text if i in hex_list or is_number(i)]
test_input_for_hex.py:##print (in_hex)
test_input_for_hex.py:
test_input_for_hex.py:##print (list(filter(lambda x: is_number(x), in_text)))
test_input_for_hex.py:
test_input_for_hex.py:in_text = list(in_text.casefold())
test_input_for_hex.py:
test_input_for_hex.py:in_text_filtered = list(filter(lambda x: not(x in in_hex), in_text))
test_input_for_hex.py:##in_text_filtered is in_text excluding values in in_hex (i.e. non_hex_values)
test_input_for_hex.py:
test_input_for_hex.py:
test_input_for_hex.py:for index, i in enumerate(in_text_filtered):
test_input_for_hex.py:    if i == " ":
test_input_for_hex.py:        in_text_filtered.pop(index)
test_input_for_hex.py:    elif is_number(i):
test_input_for_hex.py:        in_text_filtered.pop(index)
test_input_for_hex.py:
test_input_for_hex.py:##print ("#in_text_filtered", in_text_filtered)
test_input_for_hex.py:for index, i in enumerate(in_text):
test_input_for_hex.py:    if i in in_text_filtered:
test_input_for_hex.py:        print ("%s [INDEX:%s] is not a hex value" % (i, index))
test_input_for_hex.py:
test_input_for_hex.py:def split_up_hex(hex_lst):
test_input_for_hex.py:    location = 1
test_input_for_hex.py:    op_list = []
test_input_for_hex.py:    pairs = ""
test_input_for_hex.py:    if len(hex_lst) % 2 > 0:
test_input_for_hex.py:        print ("Length of hex string is not divisible by two, appending '0'")
test_input_for_hex.py:        hex_lst.append(0)
test_input_for_hex.py:    for index, i in enumerate(hex_lst):
test_input_for_hex.py:        location += 1
test_input_for_hex.py:        if location % 2 == 0:
test_input_for_hex.py:            ##print (hex_lst[index:location])
test_input_for_hex.py:            pairs += str(hex_lst[index])
test_input_for_hex.py:            pairs += str(hex_lst[location-1])
test_input_for_hex.py:            pairs += " "
test_input_for_hex.py:            ##op_list.append(hex_lst[index:location])
test_input_for_hex.py:            ##print (pairs)
test_input_for_hex.py:    #print ("#pairs:", pairs)
test_input_for_hex.py:    return pairs
test_input_for_hex.py:
test_input_for_hex.py:def pairs_list(hex_pairs):
test_input_for_hex.py:    hex_pairs = list(hex_pairs)
test_input_for_hex.py:    hex_nums_list = []
test_input_for_hex.py:    num_count = 0
test_input_for_hex.py:    num_pair = ""
test_input_for_hex.py:    for index, i in enumerate(hex_pairs):
test_input_for_hex.py:        if i != " ":
test_input_for_hex.py:            num_count += 1
test_input_for_hex.py:        if num_count == 2:
test_input_for_hex.py:            ##print (hex_pairs[index-1], hex_pairs[index])
test_input_for_hex.py:            num_count = 0
test_input_for_hex.py:            num_pair = hex_pairs[index-1] + hex_pairs[index]
test_input_for_hex.py:            hex_nums_list.append(num_pair)
test_input_for_hex.py:    #print (hex_nums_list)
test_input_for_hex.py:    return hex_nums_list
test_input_for_hex.py:
test_input_for_hex.py:def pairs_num_value(hex_pairs):
test_input_for_hex.py:    dbl_array = []
test_input_for_hex.py:    for index, i in enumerate(hex_pairs):
test_input_for_hex.py:        ##print (index, i)
test_input_for_hex.py:        dbl_array.append([hex_pairs[index][0], hex_pairs[index][1]])
test_input_for_hex.py:        ##creates 2d array | [[0,1],[2,3]]
test_input_for_hex.py:    num_array = []
test_input_for_hex.py:    for i, k in dbl_array:
test_input_for_hex.py:        if (is_number(i) == False) and (is_number(k) == False):
test_input_for_hex.py:            i = hex_dict[i]
test_input_for_hex.py:            k = hex_dict[k]
test_input_for_hex.py:            num_array.append([int(i), int(k)])
test_input_for_hex.py:        elif (is_number(i) == False):
test_input_for_hex.py:            i = hex_dict[i]
test_input_for_hex.py:            num_array.append([int(i), int(k)])
test_input_for_hex.py:        elif (is_number(k) == False):
test_input_for_hex.py:            k = hex_dict[k]
test_input_for_hex.py:            num_array.append([int(i), int(k)])
test_input_for_hex.py:        else:
test_input_for_hex.py:            num_array.append([int(i), int(k)])
test_input_for_hex.py:    #print (dbl_array)
test_input_for_hex.py:    #print (num_array)
test_input_for_hex.py:    return (num_array)
test_input_for_hex.py:
test_input_for_hex.py:def pairs_value(num_pairs):
test_input_for_hex.py:    values = []
test_input_for_hex.py:    values_str = ""
test_input_for_hex.py:    for i, k in num_pairs:
test_input_for_hex.py:        ##print (i, k)
test_input_for_hex.py:        values.append((i*(16) + k))
test_input_for_hex.py:    print ("#values", values, "\n")
test_input_for_hex.py:    for i in values:
test_input_for_hex.py:        if len(str(i)) < 2:
test_input_for_hex.py:            ##print ("#i", i)
test_input_for_hex.py:            values_str += "0" + str(i) + " "
test_input_for_hex.py:        else:
test_input_for_hex.py:            values_str += str(i) + " "
test_input_for_hex.py:    print ("#values_str", values_str, "\n")
test_input_for_hex.py:    return values_str
test_input_for_hex.py:
test_input_for_hex.py:def activate():
test_input_for_hex.py:    in_text = input("Please give a hex value:    ")
test_input_for_hex.py:
test_input_for_hex.py:    if in_text == "signature":
test_input_for_hex.py:        print (signature)
test_input_for_hex.py:        exit()
test_input_for_hex.py:    in_text_ns = list(filter(lambda x: x != " ", in_text))
test_input_for_hex.py:    ##print (in_text_ns)
test_input_for_hex.py:
test_input_for_hex.py:    in_text = ""
test_input_for_hex.py:    for i in in_text_ns:
test_input_for_hex.py:        in_text += i
test_input_for_hex.py:    print (in_text)
test_input_for_hex.py:
test_input_for_hex.py:    in_hex = [i for i in in_text if i in hex_list or is_number(i)]
test_input_for_hex.py:    ##print (in_hex)
test_input_for_hex.py:
test_input_for_hex.py:    ##print (list(filter(lambda x: is_number(x), in_text)))
test_input_for_hex.py:
test_input_for_hex.py:    in_text = list(in_text.casefold())
test_input_for_hex.py:
test_input_for_hex.py:    in_text_filtered = list(filter(lambda x: not(x in in_hex), in_text))
test_input_for_hex.py:    ##in_text_filtered is in_text excluding values in in_hex (i.e. non_hex_values)
test_input_for_hex.py:
test_input_for_hex.py:
test_input_for_hex.py:    for index, i in enumerate(in_text_filtered):
test_input_for_hex.py:        if i == " ":
test_input_for_hex.py:            in_text_filtered.pop(index)
test_input_for_hex.py:        elif is_number(i):
test_input_for_hex.py:            in_text_filtered.pop(index)
test_input_for_hex.py:
test_input_for_hex.py:    ##print ("#in_text_filtered", in_text_filtered)
test_input_for_hex.py:    for index, i in enumerate(in_text):
test_input_for_hex.py:        if i in in_text_filtered:
test_input_for_hex.py:            print ("%s [INDEX:%s] is not a hex value" % (i, index))
test_input_for_hex.py:
test_input_for_hex.py:        in_pairs = split_up_hex(in_hex)
test_input_for_hex.py:        print ("\n")
test_input_for_hex.py:        print ("#in_pairs", in_pairs, "\n")
test_input_for_hex.py:        pairs = pairs_list(in_pairs)
test_input_for_hex.py:        pairs_num = pairs_num_value(pairs)
test_input_for_hex.py:        hex_values = pairs_value(pairs_num)
test_input_for_hex.py:        print ("\n")
test_input_for_hex.py:        print (hex_values)
test_input_for_hex.py:##print ("\n" + signature)
test_input_for_hex.py:"""for DEBUG purposes, use "0123456789 abcdefg hijkl XxYyZz 0a 00 6a af b"""
test_input_for_hex.py:
test_input_for_hex.py:"""TAA-DAA!"""
test_input_for_hex.py:if __name__ == "__main__":
test_input_for_hex.py:    activate()
test_input_for_hex.py:print (__name__)
turtle_controlled.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_controlled.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_controlled.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_controlled.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_controlled.py:import my_turtle as turtle
turtle_controlled.py:import random
turtle_controlled.py:from number_funct import *
turtle_controlled.py:import sys
turtle_controlled.py:import time
turtle_controlled.py:from collections import OrderedDict
turtle_controlled.py:
turtle_controlled.py:
turtle_controlled.py:
turtle_controlled.py:screen = turtle.Screen()
turtle_controlled.py:##my_turtle = turtle.Turtle()
turtle_controlled.py:
turtle_controlled.py:colors = ("red", "orange", "yellow", "green", "blue", "purple", "black",)
turtle_controlled.py:
turtle_controlled.py:def good_input(in_query, g, b=None, c=None):
turtle_controlled.py:    isGood = False
turtle_controlled.py:    while (isGood == False):
turtle_controlled.py:        ans = input(in_query).casefold()
turtle_controlled.py:        if (ans == g) or (ans == b) or (ans == c):
turtle_controlled.py:            isGood = True
turtle_controlled.py:            return isGood, ans
turtle_controlled.py:        else:
turtle_controlled.py:            if (c is None):
turtle_controlled.py:                print ("Please answer with " + g + " or " + b + "\n Your answer: %s" % ans)
turtle_controlled.py:                ans = ""
turtle_controlled.py:            else:
turtle_controlled.py:                print ("Please answer with " + g + " or " + b + " or " + c + "\n Your answer: %s" % ans)
turtle_controlled.py:                ans = ""
turtle_controlled.py:
turtle_controlled.py:def create_turtle():
turtle_controlled.py:    name = input("Please give your turtle a name: \n")
turtle_controlled.py:    isRight = "You named your turtle %s, are you sure? \n [y] or [n] \n" % name
turtle_controlled.py:    good_in = good_input(isRight, "y", "n")
turtle_controlled.py:    if good_in[0] == True:
turtle_controlled.py:        if good_in[1] == "y":
turtle_controlled.py:            print ("You created a turtle! \n His/Her name is %s" % name)
turtle_controlled.py:            usr_turtle = turtle.Turtle(name=name)
turtle_controlled.py:            return usr_turtle
turtle_controlled.py:        elif good_in[1] == "n":
turtle_controlled.py:            create_turtle()
turtle_controlled.py:    else:
turtle_controlled.py:        print ("Please only answer with 'y' or 'n' \n your answer was %s" % good_in[1])
turtle_controlled.py:        create_turtle()
turtle_controlled.py:
turtle_controlled.py:def switchpen(t):
turtle_controlled.py:        if t.isdown():
turtle_controlled.py:            t.pu()
turtle_controlled.py:        else:
turtle_controlled.py:            t.pd()
turtle_controlled.py:
turtle_controlled.py:usr_turtle = create_turtle()
turtle_controlled.py:
turtle_controlled.py:##screen.listen()
turtle_controlled.py:
turtle_controlled.py:def spiral(t, kind, size, psize):
turtle_controlled.py:    old_psize = t.pensize()
turtle_controlled.py:    rt_amount = 1
turtle_controlled.py:    color_index = 0
turtle_controlled.py:    t.pensize(psize)
turtle_controlled.py:    if kind.casefold() == "dashed":
turtle_controlled.py:        for i in range(size):
turtle_controlled.py:            t.fd(10)
turtle_controlled.py:            switchpen(t)
turtle_controlled.py:            t.rt(rt_amount)
turtle_controlled.py:            rt_amount += 0.5
turtle_controlled.py:    elif kind.casefold() == "dashed colored":
turtle_controlled.py:        for i in range(size):
turtle_controlled.py:            t.pencolor(colors[color_index])
turtle_controlled.py:            t.fd(10)
turtle_controlled.py:            switchpen(t)
turtle_controlled.py:            t.rt(rt_amount)
turtle_controlled.py:            rt_amount += 0.5
turtle_controlled.py:            color_index += 1
turtle_controlled.py:            if color_index == len(colors):
turtle_controlled.py:                color_index = 0
turtle_controlled.py:    elif kind.casefold() == "colored":
turtle_controlled.py:        for i in range(size):
turtle_controlled.py:            t.pencolor(colors[color_index])
turtle_controlled.py:            t.fd(10)
turtle_controlled.py:            t.rt(rt_amount)
turtle_controlled.py:            rt_amount += 0.5
turtle_controlled.py:            color_index += 1
turtle_controlled.py:            if color_index == len(colors):
turtle_controlled.py:                color_index = 0
turtle_controlled.py:    t.pencolor("black")
turtle_controlled.py:    t.pensize(old_psize)
turtle_controlled.py:    t.write("Press 'q' to quit!")
turtle_controlled.py:
turtle_controlled.py:def SWORDZ_spiral(t, num, spd):
turtle_controlled.py:    rt_amount = 50
turtle_controlled.py:    t.speed(spd)
turtle_controlled.py:    for i in range(num):
turtle_controlled.py:        if i % 30 == 0:
turtle_controlled.py:            print (i, "\n", rt_amount)
turtle_controlled.py:            rt_amount += 10
turtle_controlled.py:        t.begin_fill()
turtle_controlled.py:        t.fillcolor(random.choice(colors))
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(30)
turtle_controlled.py:        t.right(45)
turtle_controlled.py:        t.fd(5)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(5)
turtle_controlled.py:        t.right(45)
turtle_controlled.py:        t.fd(30)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.pu()
turtle_controlled.py:        t.rt(rt_amount)
turtle_controlled.py:        t.fd(50)
turtle_controlled.py:        t.pd()
turtle_controlled.py:        t.end_fill()
turtle_controlled.py:        if i == 360:
turtle_controlled.py:            t.write("Tada!")
turtle_controlled.py:            time.sleep(2)
turtle_controlled.py:            t.reset()
turtle_controlled.py:            sys.exit()
turtle_controlled.py:        
turtle_controlled.py:##spiral(usr_turtle, "dashed colored", 50, 5)
turtle_controlled.py:##usr_turtle.reset()
turtle_controlled.py:##spiral(usr_turtle, "dashed", 50, 3)
turtle_controlled.py:##usr_turtle.reset()
turtle_controlled.py:##spiral(usr_turtle, "colored", 100, 3)
turtle_controlled.py:
turtle_controlled.py:##usr_turtle.reset()
turtle_controlled.py:
turtle_controlled.py:def SWORDZ_random(t, num, spd):
turtle_controlled.py:    ##print (screen.screensize()) >>> (300, 400)
turtle_controlled.py:    t.speed(spd)
turtle_controlled.py:    for i in range(num):
turtle_controlled.py:        t.rt(random.choice(range(0, 360)))
turtle_controlled.py:        Xpos = random.choice(range(-300, 300))
turtle_controlled.py:        Ypos = random.choice(range(-400, 400))
turtle_controlled.py:        t.pu()
turtle_controlled.py:        t.goto(Xpos, Ypos)
turtle_controlled.py:        t.pd()
turtle_controlled.py:        t.begin_fill()
turtle_controlled.py:        t.fillcolor(random.choice(colors))
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(30)
turtle_controlled.py:        t.right(45)
turtle_controlled.py:        t.fd(5)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(5)
turtle_controlled.py:        t.right(45)
turtle_controlled.py:        t.fd(30)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.right(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.left(90)
turtle_controlled.py:        t.fd(10)
turtle_controlled.py:        t.pu()
turtle_controlled.py:        t.pd()
turtle_controlled.py:        t.end_fill()
turtle_controlled.py:
turtle_controlled.py:"""
turtle_controlled.py:def _onscreenclick(self, fun, num=1, add=None):
turtle_controlled.py:        #"#"#"Bind fun to mouse-click event on canvas.
turtle_controlled.py:        fun must be a function with two arguments, the coordinates
turtle_controlled.py:        of the clicked point on the canvas.
turtle_controlled.py:        num, the number of the mouse-button defaults to 1
turtle_controlled.py:
turtle_controlled.py:        If a turtle is clicked, first _onclick-event will be performed,
turtle_controlled.py:        then _onscreensclick-event.
turtle_controlled.py:        #"#"#"
turtle_controlled.py:        if fun is None:
turtle_controlled.py:            self.cv.unbind("<Button-%s>" % num)
turtle_controlled.py:        else:
turtle_controlled.py:            def eventfun(event):
turtle_controlled.py:                x, y = (self.cv.canvasx(event.x)/self.xscale,
turtle_controlled.py:                        -self.cv.canvasy(event.y)/self.yscale)
turtle_controlled.py:                fun(x, y)
turtle_controlled.py:            self.cv.bind("<Button-%s>" % num, eventfun, add)
turtle_controlled.py:"""
turtle_controlled.py:def p_goto(xdummy, ydummy):
turtle_controlled.py:    usr_turtle.pu()
turtle_controlled.py:    usr_turtle.goto(xdummy, ydummy)
turtle_controlled.py:    usr_turtle.pd()
turtle_controlled.py:
turtle_controlled.py:##action = good_input("SWORDZ? \n [s]piral or [r]andom \n ", "s", "r")[1]
turtle_controlled.py:##if action == "s":
turtle_controlled.py:##    SWORDZ_spiral(usr_turtle, 1000, 500)
turtle_controlled.py:##    screen.listen()
turtle_controlled.py:##elif action == "r":
turtle_controlled.py:##    SWORDZ_random(usr_turtle, 1000, 500)
turtle_controlled.py:##    screen.listen()
turtle_controlled.py:"""
turtle_controlled.py:def _onclick(self, item, fun, num=1, add=None):
turtle_controlled.py:        #"#"#"Bind fun to mouse-click event on turtle.
turtle_controlled.py:        fun must be a function with two arguments, the coordinates
turtle_controlled.py:        of the clicked point on the canvas.
turtle_controlled.py:        num, the number of the mouse-button defaults to 1
turtle_controlled.py:        #"#"#"
turtle_controlled.py:        if fun is None:
turtle_controlled.py:            self.cv.tag_unbind(item, "<Button-%s>" % num)
turtle_controlled.py:        else:
turtle_controlled.py:            def eventfun(event):
turtle_controlled.py:                x, y = (self.cv.canvasx(event.x)/self.xscale,
turtle_controlled.py:                        -self.cv.canvasy(event.y)/self.yscale)
turtle_controlled.py:                fun(x, y)
turtle_controlled.py:            self.cv.tag_bind(item, "<Button-%s>" % num, eventfun, add)
turtle_controlled.py:"""
turtle_controlled.py:
turtle_controlled.py:def draw():
turtle_controlled.py:    colors = ("red", "orange", "yellow", "green", "blue", "purple", "black")
turtle_controlled.py:    t_names = ["r", "o", "y", "g", "b", "p", "bl"]
turtle_controlled.py:    turtles = []
turtle_controlled.py:    usr_quit = False
turtle_controlled.py:    q_btn = turtle.Turtle()
turtle_controlled.py:    q_btn.pu()
turtle_controlled.py:    q_btn.hideturtle()
turtle_controlled.py:    q_btn.goto(290, -300)
turtle_controlled.py:    q_btn.showturtle()
turtle_controlled.py:    q_btn.write("Quit", align="center", font=("Cooper Black", 12, "normal"))
turtle_controlled.py:    
turtle_controlled.py:    ##screen.onclick(usr_turtle.goto)
turtle_controlled.py:    usr_turtle.ondrag(usr_turtle.goto)
turtle_controlled.py:    screen.listen()
turtle_controlled.py:    screen.onclick(p_goto)
turtle_controlled.py:    screen.onkeypress(usr_turtle.reset, "r")
turtle_controlled.py:    T_xLoc = -200
turtle_controlled.py:    for index, i in enumerate(colors):
turtle_controlled.py:        n = t_names[index]
turtle_controlled.py:        t = turtle.Turtle(name = n)
turtle_controlled.py:        turtles.append(t)#, t.name)
turtle_controlled.py:        t.hideturtle()
turtle_controlled.py:        t.pu()
turtle_controlled.py:        t.goto(T_xLoc, -300)
turtle_controlled.py:        t.showturtle()
turtle_controlled.py:        t.pencolor(i)
turtle_controlled.py:        t.fillcolor(i)
turtle_controlled.py:        t.write(i, "%s Pallete" % i, align="right", font=("Cooper Black", 12, "normal"))
turtle_controlled.py:        t.onclick(usr_turtle.pencolor, args=i)
turtle_controlled.py:        print (i)
turtle_controlled.py:        T_xLoc += 60
turtle_controlled.py:        ##print ("#DEBUG", t.name)
turtle_controlled.py:    screen.onkeypress(quit, "q")
turtle_controlled.py:    print (turtles)
turtle_controlled.py:        
turtle_controlled.py:    
turtle_controlled.py:
turtle_controlled.py:if __name__ == "__main__":
turtle_controlled.py:    draw()
turtle_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_test.py:C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_test.py:#! C:UsersMichaelLFarwellAppDataLocalProgramsPythonPython35-32python.exe
turtle_test.py:﻿import turtle
turtle_test.py:import sys
turtle_test.py:import os
turtle_test.py:"""TO REFERENCE TURTLE OBJECTS: 'turtle.module.object'
turtle_test.py:EX.
turtle_test.py:    print (turtle.math.pi)
turtle_test.py:    >>> 3.14159265
turtle_test.py:"""
turtle_test.py:
turtle_test.py:my_turtle = turtle.Turtle()
turtle_test.py:screen = turtle.Screen()
turtle_test.py:methods = ["tri", "spiral", "tri_circle"]
turtle_test.py:
turtle_test.py:def tri():
turtle_test.py:    my_turtle.begin_poly()
turtle_test.py:    for i in range(3):
turtle_test.py:        my_turtle.fd(60)
turtle_test.py:        my_turtle.rt(120)
turtle_test.py:    screen.reset()
turtle_test.py:    my_turtle.end_poly()
turtle_test.py:
turtle_test.py:def spiral(x, y):
turtle_test.py:    my_turtle.reset()
turtle_test.py:    deg = 90
turtle_test.py:    move = 0.5
turtle_test.py:    for i in range(90):
turtle_test.py:        my_turtle.fd(move)
turtle_test.py:        my_turtle.right(deg)
turtle_test.py:        deg -= 1
turtle_test.py:        move += 0.5
turtle_test.py:    my_turtle.reset()
turtle_test.py:
turtle_test.py:my_turtle.onclick(spiral)
turtle_test.py:
turtle_test.py:def tri_circle():
turtle_test.py:    my_turtle.reset()
turtle_test.py:    ghost = turtle.getturtle()
turtle_test.py:    ghost.hideturtle()
turtle_test.py:    ghost.pu()
turtle_test.py:    ghost.begin_fill()
turtle_test.py:    colors = ["red", "green", "blue"]
turtle_test.py:    c_place = 0
turtle_test.py:    for i in range(3):
turtle_test.py:        ghost.fd(60)
turtle_test.py:        my_turtle.fd(60)
turtle_test.py:        my_turtle.begin_fill()
turtle_test.py:        my_turtle.fillcolor(colors[c_place])
turtle_test.py:        my_turtle.circle(10, 360)
turtle_test.py:        my_turtle.end_fill()
turtle_test.py:        c_place += 1
turtle_test.py:        my_turtle.rt(120)
turtle_test.py:        ghost.rt(120)
turtle_test.py:    ghost.end_fill()
turtle_test.py:    my_turtle.hideturtle()
turtle_test.py:    full_reset()
turtle_test.py:
turtle_test.py:def run():
turtle_test.py:    screen.onkeypress(tri_circle, "a")
turtle_test.py:    screen.listen()
turtle_test.py:    screen.onkeypress(quit, "Escape")
turtle_test.py:    my_turtle.onclick(spiral)
turtle_test.py:    screen.onkeypress(tri, "t")
turtle_test.py:    
turtle_test.py:print (__name__)
turtle_test.py:if __name__ == "__main__":
turtle_test.py:    run()
